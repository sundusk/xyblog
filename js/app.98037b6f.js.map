{"version":3,"file":"js/app.98037b6f.js","mappings":"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","sources":["webpack://my-blog/./src/posts/JavaScript后端使用-创建API.md","webpack://my-blog/./src/posts/Python简单的开发流程.md","webpack://my-blog/./src/posts/Vue 组件全局样式和作用域问题：避免页面上下出现白色间隔.md","webpack://my-blog/./src/posts/Vue笔记-注册路由跳转.md","webpack://my-blog/./src/posts/Vue笔记-项目创建.md","webpack://my-blog/./src/posts/macOS下本地 MongoDB 安装、启动及项目集成指南.md","webpack://my-blog/./src/posts/分类和标签管理实现总结.md","webpack://my-blog/./src/posts/博客管理系统后端-注册、登录、令牌.md","webpack://my-blog/./src/posts/博客管理系统后端-项目搭建.md","webpack://my-blog/./src/posts/博文章管理 CRUD 实现.md","webpack://my-blog/./src/posts/文章管理系统开发笔记.md","webpack://my-blog/./src/App.vue","webpack://my-blog/./src/App.vue?7ccd","webpack://my-blog/./src/components/XYHome.vue","webpack://my-blog/./src/components/XYHome.vue?bb05","webpack://my-blog/./src/components/XYBlogDetail.vue","webpack://my-blog/./src/components/XYBlogDetail.vue?d1b4","webpack://my-blog/./src/router/index.js","webpack://my-blog/./src/main.js","webpack://my-blog/./src/posts/ sync nonrecursive \\.md$","webpack://my-blog/webpack/bootstrap","webpack://my-blog/webpack/runtime/chunk loaded","webpack://my-blog/webpack/runtime/compat get default export","webpack://my-blog/webpack/runtime/define property getters","webpack://my-blog/webpack/runtime/global","webpack://my-blog/webpack/runtime/hasOwnProperty shorthand","webpack://my-blog/webpack/runtime/make namespace object","webpack://my-blog/webpack/runtime/jsonp chunk loading","webpack://my-blog/webpack/startup"],"sourcesContent":["export default \"---\\ntitle: \\\"JavaScript后端使用-创建API\\\"\\ndate: \\\"2024-10-30\\\"\\n---\\n\\n一、项目创建与环境配置\\n\\n1. 初始化Node.js项目\\n   后端的基础是Node.js，而Express则是一个轻量级的Web框架，可以快速构建API接口。下面是我创建一个Node.js项目的基本步骤：\\n\\n2. 安装Node.js： 如果你还没有安装Node.js，可以去 Node.js官网 下载并安装。\\n\\n3. 创建项目文件夹并初始化项目：\\n   首先，进入项目文件夹并使用 npm init 初始化项目，生成 package.json 文件：\\n\\n   ```\\n   mkdir blog-backend\\n   cd blog-backend\\n   npm init -y\\n   ```\\n\\n   其中，`-y` 参数可以跳过一系列手动配置，快速生成 `package.json`。\\n\\n4. 安装必要依赖：\\n   接下来，我安装了后端所需的依赖，包括 `express`（用于构建Web服务器）和 `cors`（用于解决跨域问题）：\\n\\n   ```\\n   npm install express cors\\n   ```\\n\\n5. 创建基础Express服务器\\n\\n完成环境配置后，我开始编写最基本的Express服务器代码。这是我的 `server.js` 文件内容：\\n\\n```javascript\\nconst express = require('express');\\nconst cors = require('cors');\\nconst app = express();\\n\\napp.use(cors()); // 允许跨域请求\\n\\n// 定义一个简单的API返回动态标题\\napp.get('/api/title', (req, res) => {\\n  const title = '强风吹拂，聚散流云';\\n  res.json({ title });\\n});\\n\\nconst PORT = 3000;\\napp.listen(PORT, () => {\\n  console.log(`Server running on http://localhost:${PORT}`);\\n});\\n```\\n\\nExpress框架： 用于快速创建一个可以处理HTTP请求的Web服务器。\\nCORS中间件： 用来解决前后端不同源之间的跨域问题。\\n基本API： 我定义了 /api/title 路由，向前端返回一个简单的标题，接下来会通过前端Axios请求这个数据并展示出来。\\n\\n3. 启动服务器\\n   通过以下命令来启动Express服务器：\\n\\n```\\nnode server.js\\n```\\n\\n服务器启动后，控制台会输出 `Server running on http://localhost:3000`，表示后端服务已经准备好。\\n\\n---\\n\\n二、前后端的联动\\n\\n1. 用Axios从后端获取数据\\n\\n为了将后端的数据展示在前端，我使用了 `axios` 库。Axios可以很方便地向后端API发送请求，并获取返回的数据。以下是我如何在前端通过Axios获取后端提供的标题，并在页面中展示的代码：\\n\\n```javascript\\nloadTitle() {\\n  axios.get('http://localhost:3000/api/title')\\n    .then(response => {\\n      this.pageTitle = response.data.title;\\n    })\\n    .catch(error => {\\n      console.error('获取标题时出错:', error);\\n    });\\n}\\n```\\n\\nAxios请求： 请求 `/api/title` 路由，获取标题数据并将其赋值给前端的 `pageTitle`。\\n错误处理： 如果请求失败，将在控制台输出错误信息。\\n\\n2. 实现动态背景图\\n\\n接下来，我实现了从后端获取背景图片的功能。为了更好地管理图片，我将图片上传到了GitHub仓库，然后通过后端API将图片URL返回给前端，动态设置背景图。\\n\\n后端API代码：\\n\\n```javascript\\napp.get('/api/background', (req, res) => {\\n  const backgroundImageUrl = 'https://raw.githubusercontent.com/sundusk/blogBackImage/main/one.png';\\n  res.json({ backgroundImage: backgroundImageUrl });\\n});\\n```\\n\\n前端通过Axios获取背景图URL，并将其设置为页面背景：\\n\\n```javascript\\nloadBackgroundImage() {\\n  axios.get('http://localhost:3000/api/background')\\n    .then(response => {\\n      document.querySelector('.rounded-bg').style.backgroundImage = `url(${response.data.backgroundImage})`;\\n    })\\n    .catch(error => {\\n      console.error('获取背景图时出错:', error);\\n    });\\n}\\n```\\n\\n这样，前端的背景图片可以动态地从后端获取，增强了项目的灵活性。\\n\\n---\\n\\n三、优化开发流程\\n\\n1. 引入Nodemon自动重启\\n\\n在开发过程中，我发现每次修改后端代码都需要手动重启服务器，这非常影响开发效率。于是，我引入了 `nodemon` 这个工具，它可以在检测到代码变动时自动重启服务器。\\n\\n使用以下命令安装 `nodemon`：\\n\\n```bash\\nsudo npm install -g nodemon\\n```\\n\\n安装成功后，我用以下命令启动服务器，代替原来的 `node` 命令：\\n\\n```bash\\nnodemon server.js\\n```\\n\\nNodemon会监控项目中的文件变化，自动重启服务器，大大提高了开发效率。\\n\\n2. GitHub作为资源管理器\\n\\n在全栈开发中，图片资源的管理是非常重要的。为此，我将图片资源上传至GitHub仓库，并通过GitHub的外链进行管理。在后端API中直接返回图片的URL，这不仅解决了存储问题，还提升了加载效率。\\n\\n---\\n\\n四、项目架构与代码结构的思考\\n\\n在项目开发过程中，我也逐渐意识到代码组织的重要性。随着项目的不断增大，代码的清晰性和可维护性变得越来越重要。因此，我开始尝试将项目模块化，遵循RESTful设计原则，将不同功能的API拆分到各自的路由模块中。\\n\\n1. 将路由拆分\\n   我将不同的功能模块分开管理，创建不同的路由文件。例如，专门创建 `titleRouter.js` 和 `backgroundRouter.js` 来处理不同的API请求：\\n\\n`titleRouter.js`：\\n\\n```javascript\\nconst express = require('express');\\nconst router = express.Router();\\n\\nrouter.get('/', (req, res) => {\\n  const title = '强风吹拂，聚散流云';\\n  res.json({ title });\\n});\\n\\nmodule.exports = router;\\n```\\n\\n`backgroundRouter.js`：\\n\\n```javascript\\nconst express = require('express');\\nconst router = express.Router();\\n\\nrouter.get('/', (req, res) => {\\n  const backgroundImageUrl = 'https://raw.githubusercontent.com/sundusk/blogBackImage/main/one.png';\\n  res.json({ backgroundImage: backgroundImageUrl });\\n});\\n\\nmodule.exports = router;\\n```\\n\\n这样做有助于让代码更加清晰、易于维护，同时也方便日后扩展更多的API功能。\";","export default \"---\\ntitle: \\\"Python简单的开发流程\\\"\\ndate: \\\"2024-10-25\\\"\\n---\\n\\n### 一切建立在Mac环境配置完成之后，使用VSCode  \\n#### 1.创建项目名.py\\n```\\nmkdir MyPythonProject\\ncd MyPythonProject\\n```\\n#### 2.创建虚拟环境\\n之所以要创建虚拟环境，是因为各个项目的环境配置是不一样的，为了避免之后的新建项目的环境冲突，方便管理项目的依赖\\n创建虚拟环境命令行\\n```\\npython3 -m venv venv\\n```\\n激活虚拟环境命令行\\n```\\nsource venv/bin/activate\\n```\\n\\n#### 3.安装依赖\\n使用pip安装所需第三方库\\n例如\\n```\\npip install requests \\n```\\n\\n\\n#### 4.编写代码\\n#### 5.运行代码\\n```\\npython newOne.py\\n```\\n#### 6.创建可执行文件（Mac应用程序）\\n如果希望生成一个Mac应用程序包（.app），可以使用以下命令：\\n```\\npyinstaller --onefile --windowed newOne.py\\n```\\n\\n#### 7.清理并关闭虚拟环境\\n在完成开发后，激活的虚拟环境是需要关闭的\\n```\\ndeactivate\\n```\\n\";","export default \"---\\ntitle: \\\"Vue 组件全局样式和作用域问题：避免页面上下出现白色间隔\\\"\\ndate: \\\"2024-11-08\\\"\\n---\\n\\n在使用 Vue.js 进行开发时，我们经常会遇到样式作用范围的问题。尤其是在设置页面的背景颜色时，如果没有正确处理全局样式，可能会导致页面上下出现不需要的白色间隔。本文将通过一个具体的例子来说明如何避免这种情况。\\n\\n## 问题描述\\n\\n假设我们有一个 `UserLogin.vue` 文件，它定义了一个简单的登录页面，我们希望页面的背景颜色是黑色。但在实际渲染时，页面上下却出现了白色的间隔。如下是可能导致该问题的代码示例：\\n\\n```vue\\n<template>\\n  <div class=\\\"user-login\\\">\\n    <h1>登录</h1>\\n    <p>这是一个基本的用户登录页面。</p>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: \\\"UserLogin\\\",\\n};\\n</script>\\n\\n<style scoped>\\n.user-login {\\n  background-color: black;\\n  color: white; /* 设置文字颜色为白色 */\\n  height: 100vh;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  flex-direction: column;\\n}\\n</style>\\n```\\n\\n### 问题分析\\n\\n在 Vue 组件中，使用 `<style scoped>` 会让样式只作用于当前组件的 HTML 结构内部，而不会影响到整个页面的 `html` 和 `body` 元素。因此，上述代码虽然设置了 `.user-login` 的背景颜色，但并没有覆盖到全局的 `html` 和 `body`，导致页面上下出现了白色区域。\\n\\n### 解决方法\\n\\n为了确保背景颜色在整个页面中一致，我们可以通过以下方法来解决这个问题：\\n\\n1. **在根组件或全局样式文件中定义 `html` 和 `body` 的样式**。通过全局应用样式，我们可以确保整个页面的布局和背景颜色保持一致。\\n\\n2. **去掉 `scoped`，直接在 `UserLogin.vue` 中定义 `html` 和 `body` 的样式**。\\n\\n以下是修改后的 `UserLogin.vue` 代码：\\n\\n```vue\\n<template>\\n  <div class=\\\"user-login\\\">\\n    <h1>登录</h1>\\n    <p>这是一个基本的用户登录页面。</p>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: \\\"UserLogin\\\",\\n};\\n</script>\\n\\n<style lang=\\\"scss\\\">\\n/* 全局设置 html 和 body 样式 */\\nhtml,\\nbody {\\n  margin: 0;\\n  padding: 0;\\n  background-color: black;\\n  color: white;\\n  height: 100%; /* 确保占满全屏 */\\n}\\n\\n.user-login {\\n  height: 100vh;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  flex-direction: column;\\n}\\n</style>\\n```\\n\\n### 总结\\n\\n通过直接设置 `html` 和 `body` 的全局样式，可以确保整个页面的背景色和布局一致，从而避免顶部和底部出现白色间隔。这种方式不会因为 `scoped` 限制作用域而影响整体布局效果。\\n\\n希望这个方法能帮助你在 Vue 项目中更好地控制页面样式。如果以后遇到类似的问题，可以检查是否是 `scoped` 样式导致的问题，并选择合适的方式将样式作用到全局。\\n\\n---\\n\\n**参考：**\\n\\n- [Vue.js 官方文档 - Scoped 样式](https://vuejs.org/guide/scoped-styles.html)\\n\";","export default \"---\\ntitle: \\\"Vue笔记-注册路由跳转\\\"\\ndate: \\\"2024-10-25\\\"\\n---\\n\\n### 项目结构\\n\\n```\\nsrc/\\n  components/\\n    HelloWorld.vue\\n    NewOneComponent.vue\\n  router/\\n    index.js\\n  App.vue\\n  main.js\\n```\\n\\n### 一、安装Vue Router\\n\\n首先，确保项目中已安装 Vue Router。如果没有安装，可以使用以下命令安装：\\n\\n```终端\\nnpm install vue-router@next\\n```\\n\\n### 二、创建路由配置文件\\n\\n在 src 目录下创建一个 router 文件夹，并在其中创建一个 index.js 文件，定义路由配置：\\n\\n```javascript\\n// src/router/index.js\\nimport { createRouter, createWebHistory } from 'vue-router';\\nimport HelloWorld from '../components/HelloWorld.vue';\\nimport NewOneComponent from '../components/NewOneComponent.vue';\\n\\nconst routes = [\\n  { path: '/', component: HelloWorld },\\n  { path: '/NewOneComponent', component: NewOneComponent }\\n];\\n\\nconst router = createRouter({\\n  history: createWebHistory(),\\n  routes\\n});\\n\\nexport default router;\\n```\\n\\n### 三、在 main.js 中引入并使用路由\\n\\n在 main.js 文件中引入并使用路由：\\n\\n```javascript\\n// src/main.js\\nimport { createApp } from 'vue';\\nimport App from './App.vue';\\nimport router from './router';\\n\\ncreateApp(App).use(router).mount('#app');\\n```\\n\\n### 四、配置主组件以支持路由视图\\n\\n在 App.vue 文件中添加 <router-view> 标签，用于显示匹配的路由组件：\\n\\n```javascript\\n<!-- src/App.vue -->\\n<template>\\n  <div id=\\\"app\\\">\\n    <img alt=\\\"Vue logo\\\" src=\\\"./assets/logo.png\\\">\\n    <router-view></router-view>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'App'\\n}\\n</script>\\n\\n<style>\\n#app {\\n  font-family: Avenir, Helvetica, Arial, sans-serif;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n  text-align: center;\\n  color: #2c3e50;\\n  margin-top: 60px;\\n}\\n</style>\\n```\\n\\n### 五、配置要跳转的组件\\n\\n在 HelloWorld.vue 组件中添加按钮和点击事件，以实现页面跳转：\\n\\n```javascript\\n<template>\\n  <div>\\n    这是新的初始页面\\n    <button @click=\\\"goToNewPage\\\">跳转到 NewOne 页面</button>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'HelloWorld',\\n  methods: {\\n    goToNewPage() {\\n      this.$router.push('/NewOneComponent');\\n    }\\n  }\\n}\\n</script>\\n```\\n\\n### 六、确保跳转目标组件存在并正确配置\\n\\n```javascript\\n<!-- src/components/NewOneComponent.vue -->\\n<template>\\n  <div>\\n    这是个网页哦\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'NewOneComponent'\\n}\\n</script>\\n```\\n\\n配置完成后，开启本地服务器运行项目，查看是否正常\\n\";","export default \"---\\ntitle: \\\"Vue笔记-项目创建\\\"\\ndate: \\\"2024-10-25\\\"\\n---\\n\\n### 创建vue项目\\n\\n1.在配置环境完成之后，在终端运行指令创建项目\\n\\n`vue create my-project`\\n\\n2.运行项目，在终端中输入命令行来启动服务器\\n\\n`npm run serve`\\n\\n### Vue目录结构\\n\\n| 目录/文件    | 说明                                                         |\\n| :----------- | :----------------------------------------------------------- |\\n| build        | 项目构建(webpack)相关代码                                    |\\n| config       | 配置目录，包括端口号等。我们初学可以使用默认的。             |\\n| node_modules | npm 加载的项目依赖模块                                       |\\n| src          | 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件。 |\\n| static       | 静态资源目录，如图片、字体等。                               |\\n| test         | 初始测试目录，可删除                                         |\\n| .xxxx文件    | 这些是一些配置文件，包括语法配置，git配置等。                |\\n| index.html   | 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。       |\\n| package.json | 项目配置文件。                                               |\\n| README.md    | 项目的说明文档，markdown 格式                                |\\n\\n也就是说，正常开发的时候，在src文件夹中进行新的组件的创建\\n\\n### 创建基本组件结构\\n\\n要在新的组件页面编写代码，如下是基本的组件结构\\n\\n```\\n<template>\\n  <div class=\\\"hello\\\">\\n    <!-- 这里是模板内容 -->\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'HelloWorld',\\n  data() {\\n    return {\\n      // 这里是组件的数据\\n    }\\n  },\\n  methods: {\\n    // 这里是组件的方法\\n  }\\n}\\n</script>\\n\\n<style scoped>\\n.hello {\\n  /* 这里是组件的样式 */\\n}\\n</style>\\n```\\n\\n### 项目完成之后\\n\\n1.构建项目\\n\\n在项目的根目录下运行以下终端命令行，将vue,js应用构建为静态文件\\n\\n`npm run build`\\n\\n2.配置项目（这个是可选的）\\n\\n如果需要自定义构建配置，可以在vue.config.js文件中进行配置。例如，如果要将应用部署到子路径，可以这样配置：\\n\\n```\\nmodule.exports = {\\n\\tpublicPath: '/my-app/'\\n}\\n```\\n\\n3.部署到Web服务器\\n\";","export default \"---\\ntitle: \\\"macOS下本地 MongoDB 安装、启动及项目集成指南\\\"\\ndate: \\\"2024-10-31\\\"\\n---\\n\\n本文详细介绍了如何在 macOS 上使用 Homebrew 安装 MongoDB 社区版，启动本地 MongoDB 服务，并通过 Node.js 项目进行数据库集成。\\n\\n## 一、安装 MongoDB 社区版\\n\\n1. **更新 Homebrew：**\\n\\n   ```bash\\n   brew update\\n   ```\\n\\n2. **添加 MongoDB 官方 Tap：**\\n\\n   ```bash\\n   brew tap mongodb/brew\\n   ```\\n\\n3. **安装 MongoDB 社区版：**\\n\\n   ```bash\\n   brew install mongodb/brew/mongodb-community@7.0\\n   ```\\n\\n## 二、启动 MongoDB 服务\\n\\n- 启动 MongoDB 服务：\\n\\n  ```bash\\n  brew services start mongodb/brew/mongodb-community@7.0\\n  ```\\n\\n- 检查服务状态，确保 MongoDB 已成功启动：\\n\\n  ```bash\\n  brew services list\\n  ```\\n\\n### 连接到 MongoDB Shell\\n\\n使用以下命令进入 MongoDB Shell 进行交互：\\n\\n```bash\\nmongo\\n```\\n\\n### 停止 MongoDB 服务\\n\\n如需停止服务，可使用以下命令：\\n\\n```bash\\nbrew services stop mongodb/brew/mongodb-community@7.0\\n```\\n\\n## 三、Node.js 项目中的 MongoDB 集成\\n\\n1. **安装 Mongoose：**\\n   在 Node.js 项目中，使用 Mongoose 库连接 MongoDB。\\n\\n   ```bash\\n   npm install mongoose\\n   ```\\n\\n2. **配置数据库连接**\\n   在项目的 `server.js` 中配置 Mongoose 连接：\\n\\n   ```javascript\\n   const mongoose = require('mongoose');\\n   mongoose.connect('mongodb://localhost:27017/myBlog', {\\n     useNewUrlParser: true,\\n     useUnifiedTopology: true,\\n   });\\n   const db = mongoose.connection;\\n   db.on('error', console.error.bind(console, 'MongoDB 连接错误:'));\\n   db.once('open', () => {\\n     console.log('成功连接到 MongoDB');\\n   });\\n   ```\\n\\n3. **创建数据模型**\\n   在项目中定义博客文章的 Schema，例如在 `models/Blog.js` 文件中：\\n\\n   ```javascript\\n   const mongoose = require('mongoose');\\n   const blogSchema = new mongoose.Schema({\\n     title: { type: String, required: true },\\n     content: { type: String, required: true },\\n     date: { type: Date, default: Date.now },\\n   });\\n   const Blog = mongoose.model('Blog', blogSchema);\\n   module.exports = Blog;\\n   ```\\n\\n## 四、设置 API 路由\\n\\n在 Express 项目中创建和获取博客文章的 API 路由：\\n\\n```javascript\\nconst express = require('express');\\nconst Blog = require('./models/Blog');\\nconst app = express();\\napp.use(express.json());\\n\\n// 创建新的博客文章\\napp.post('/api/blog', async (req, res) => {\\n  try {\\n    const newBlog = new Blog(req.body);\\n    await newBlog.save();\\n    res.json({ message: '博客文章创建成功' });\\n  } catch (error) {\\n    res.status(500).json({ error: '创建博客文章时出错' });\\n  }\\n});\\n\\n// 获取所有博客文章\\napp.get('/api/blogs', async (req, res) => {\\n  try {\\n    const blogs = await Blog.find();\\n    res.json(blogs);\\n  } catch (error) {\\n    res.status(500).json({ error: '获取博客列表时出错' });\\n  }\\n});\\n\\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));\\n```\\n\\n## 五、常见问题及排查\\n\\n1. **`req.body` 是 undefined**  \\n   - 解决：确保 `app.use(express.json())` 在路由之前添加，并在请求时选择 `Content-Type` 为 `application/json`。\\n\\n2. **连接 MongoDB 时报错**  \\n   - 解决：确保 MongoDB 服务已启动，可通过 `brew services list` 查看。\\n\\n通过以上步骤，您已成功在 macOS 上安装并配置 MongoDB，并将其集成到 Node.js 项目中。\\n\";","export default \"---\\ntitle: \\\"分类和标签管理实现总结\\\"\\ndate: \\\"2024-11-08\\\"\\n---\\n\\n本文档将总结个人博客管理系统后端中 **分类和标签管理** 功能的实现过程。分类和标签帮助我们对文章进行更细致的组织和筛选，是博客管理的重要组成部分。\\n\\n## 项目结构\\n\\n在实现分类和标签管理功能后，项目结构如下：\\n\\n```\\nproject-root\\n├── src\\n│   ├── models\\n│   │   ├── Category.js       # 分类模型\\n│   │   └── Tag.js            # 标签模型\\n│   ├── routes\\n│   │   ├── category.js       # 分类管理路由\\n│   │   └── tag.js            # 标签管理路由\\n├── app.js                    # 主文件\\n└── ...\\n```\\n\\n## 1. 分类模型定义\\n\\n在 `src/models/Category.js` 中定义分类模型。每个分类包含名称和描述字段，名称字段需要唯一，以便区分不同分类。\\n\\n```javascript\\n// src/models/Category.js\\nconst mongoose = require('mongoose');\\n\\nconst categorySchema = new mongoose.Schema({\\n    name: { type: String, required: true, unique: true },  // 分类名称，必填且唯一\\n    description: { type: String }                           // 分类描述，可选\\n});\\n\\nmodule.exports = mongoose.model('Category', categorySchema);\\n```\\n\\n### 字段解释\\n\\n- **name**：分类的名称，必填且唯一，用于区分不同的分类。\\n- **description**：分类的描述，可以为每个分类提供额外说明和信息，可选字段。\\n\\n---\\n\\n## 2. 标签模型定义\\n\\n在 `src/models/Tag.js` 中定义标签模型。标签模型仅包含名称字段，且名称字段唯一，确保每个标签能够独立标识。\\n\\n```javascript\\n// src/models/Tag.js\\nconst mongoose = require('mongoose');\\n\\nconst tagSchema = new mongoose.Schema({\\n    name: { type: String, required: true, unique: true }    // 标签名称，必填且唯一\\n});\\n\\nmodule.exports = mongoose.model('Tag', tagSchema);\\n```\\n\\n### 字段解释\\n\\n- **name**：标签的名称，必填且唯一，用于标识和区分不同标签。\\n\\n---\\n\\n## 3. 分类和标签路由定义\\n\\n### 分类路由：`category.js`\\n\\n在 `src/routes/category.js` 中创建分类的增删改查（CRUD）接口，确保用户通过这些接口管理分类内容。\\n\\n```javascript\\nconst express = require('express');\\nconst auth = require('../middlewares/auth');  // 仅授权用户可以管理分类\\nconst Category = require('../models/Category');\\n\\nconst router = express.Router();\\n\\n// 创建分类\\nrouter.post('/create', auth, async (req, res) => {\\n    const { name, description } = req.body;\\n\\n    try {\\n        const category = new Category({ name, description });\\n        await category.save();\\n        res.status(201).json({ message: '分类创建成功', category });\\n    } catch (error) {\\n        res.status(500).json({ message: '分类创建失败', error });\\n    }\\n});\\n\\n// 获取所有分类\\nrouter.get('/', async (req, res) => {\\n    try {\\n        const categories = await Category.find();\\n        res.json(categories);\\n    } catch (error) {\\n        res.status(500).json({ message: '获取分类失败', error });\\n    }\\n});\\n\\n// 更新分类\\nrouter.put('/:id', auth, async (req, res) => {\\n    const { name, description } = req.body;\\n\\n    try {\\n        const category = await Category.findByIdAndUpdate(\\n            req.params.id,\\n            { name, description },\\n            { new: true }\\n        );\\n        if (!category) return res.status(404).json({ message: '分类未找到' });\\n        res.json({ message: '分类更新成功', category });\\n    } catch (error) {\\n        res.status(500).json({ message: '更新分类失败', error });\\n    }\\n});\\n\\n// 删除分类\\nrouter.delete('/:id', auth, async (req, res) => {\\n    try {\\n        const category = await Category.findByIdAndDelete(req.params.id);\\n        if (!category) return res.status(404).json({ message: '分类未找到' });\\n        res.json({ message: '分类删除成功' });\\n    } catch (error) {\\n        res.status(500).json({ message: '删除分类失败', error });\\n    }\\n});\\n\\nmodule.exports = router;\\n```\\n\\n### 标签路由：`tag.js`\\n\\n在 `src/routes/tag.js` 中创建标签的增删改查（CRUD）接口，使用户能够管理标签内容。\\n\\n```javascript\\nconst express = require('express');\\nconst auth = require('../middlewares/auth');\\nconst Tag = require('../models/Tag');\\n\\nconst router = express.Router();\\n\\n// 创建标签\\nrouter.post('/create', auth, async (req, res) => {\\n    const { name } = req.body;\\n\\n    try {\\n        const tag = new Tag({ name });\\n        await tag.save();\\n        res.status(201).json({ message: '标签创建成功', tag });\\n    } catch (error) {\\n        res.status(500).json({ message: '标签创建失败', error });\\n    }\\n});\\n\\n// 获取所有标签\\nrouter.get('/', async (req, res) => {\\n    try {\\n        const tags = await Tag.find();\\n        res.json(tags);\\n    } catch (error) {\\n        res.status(500).json({ message: '获取标签失败', error });\\n    }\\n});\\n\\n// 更新标签\\nrouter.put('/:id', auth, async (req, res) => {\\n    const { name } = req.body;\\n\\n    try {\\n        const tag = await Tag.findByIdAndUpdate(\\n            req.params.id,\\n            { name },\\n            { new: true }\\n        );\\n        if (!tag) return res.status(404).json({ message: '标签未找到' });\\n        res.json({ message: '标签更新成功', tag });\\n    } catch (error) {\\n        res.status(500).json({ message: '更新标签失败', error });\\n    }\\n});\\n\\n// 删除标签\\nrouter.delete('/:id', auth, async (req, res) => {\\n    try {\\n        const tag = await Tag.findByIdAndDelete(req.params.id);\\n        if (!tag) return res.status(404).json({ message: '标签未找到' });\\n        res.json({ message: '标签删除成功' });\\n    } catch (error) {\\n        res.status(500).json({ message: '删除标签失败', error });\\n    }\\n});\\n\\nmodule.exports = router;\\n```\\n\\n---\\n\\n## 4. 在 `app.js` 中挂载分类和标签路由\\n\\n在主文件 `app.js` 中导入分类和标签的路由文件，并挂载到指定路径，以便管理系统可以调用这些接口。\\n\\n```javascript\\nconst categoryRoutes = require('./src/routes/category');\\nconst tagRoutes = require('./src/routes/tag');\\n\\napp.use('/api/categories', categoryRoutes);\\napp.use('/api/tags', tagRoutes);\\n```\\n\\n---\\n\\n## 总结\\n\\n通过实现分类和标签的增删改查接口，个人博客管理系统的内容管理能力进一步增强。文章可以通过分类和标签进行组织和筛选，便于更细致的内容管理。分类和标签接口的实现过程包括：\\n\\n1. 定义分类和标签的 Mongoose 模型。\\n2. 在分类和标签的路由文件中创建 CRUD 接口。\\n3. 在主文件中挂载路由。\\n\\n---\\n\\n以上笔记详细记录了分类和标签管理功能的实现过程，为后续维护和扩展提供了清晰的参考。\\n\";","export default \"---\\ntitle: \\\"博客管理系统后端-注册、登录、令牌\\\"\\ndate: \\\"2024-11-08\\\"\\n---\\n\\n## 前言\\n\\n在本篇博客中，我们将详细介绍如何从零开始搭建一个基于 Node.js、Express 和 MongoDB 的后台项目。\\n本教程会以“xyblog-admin”项目为例，带领大家一步步完成基本的项目结构搭建、数据库连接、以及服务器启动。\\n\\n## 项目结构初始化\\n\\n1. 在项目目录（例如“xyblog-admin”）中，创建如下文件结构：\\n\\n   ```\\n   xyblog-admin\\n   ├── src\\n   │   ├── config          # 配置文件（如数据库连接）\\n   │   ├── controllers     # 控制器文件\\n   │   ├── middlewares     # 中间件\\n   │   ├── models          # 数据库模型\\n   │   ├── routes          # 路由\\n   │   └── utils           # 工具函数\\n   ├── .env                # 环境变量文件\\n   ├── app.js              # 项目主入口文件\\n   └── package.json        # Node.js 项目配置文件\\n   ```\\n\\n   这将帮助我们保持清晰的项目结构，便于后续扩展和维护。\\n\\n## 初始化 Node.js 项目\\n\\n1. 在项目根目录下，运行以下命令初始化 `package.json` 文件：\\n\\n   ```bash\\n   npm init -y\\n   ```\\n\\n2. 安装项目的主要依赖库：\\n\\n   ```bash\\n   npm install express mongoose dotenv jsonwebtoken bcryptjs cors\\n   ```\\n\\n3. 安装开发依赖（如 `nodemon` 用于开发环境的自动重启）：\\n\\n   ```bash\\n   npm install nodemon --save-dev\\n   ```\\n\\n4. 修改 `package.json` 文件，添加启动脚本：\\n\\n   ```json\\n   \\\"scripts\\\": {\\n       \\\"start\\\": \\\"node app.js\\\",\\n       \\\"dev\\\": \\\"nodemon app.js\\\"\\n   }\\n   ```\\n\\n## 配置主入口文件 app.js\\n\\n在根目录下创建 `app.js` 文件，配置 Express 服务器和 MongoDB 数据库连接。以下是 `app.js` 的基本配置：\\n\\n```javascript\\nconst express = require('express');\\nconst cors = require('cors');\\nconst mongoose = require('mongoose');\\nrequire('dotenv').config();\\n\\nconst app = express();\\nconst PORT = process.env.PORT || 5000;\\n\\napp.use(cors());\\napp.use(express.json());\\n\\n// 数据库连接\\nmongoose.connect(process.env.MONGODB_URI, {\\n    useNewUrlParser: true,\\n    useUnifiedTopology: true,\\n})\\n.then(() => console.log('MongoDB Connected'))\\n.catch((err) => console.log(err));\\n\\n// 基础路由测试\\napp.get('/', (req, res) => {\\n    res.send('xyblog Admin API Running');\\n});\\n\\napp.listen(PORT, () => {\\n    console.log(`Server running on port ${PORT}`);\\n});\\n```\\n\\n确保 `.env` 文件中定义了 `PORT` 和 `MONGODB_URI` 环境变量。\\n\\n## 创建 .env 文件\\n\\n在项目根目录下手动创建 `.env` 文件，配置以下内容：\\n\\n```plaintext\\nPORT=3000\\nMONGODB_URI=mongodb://localhost:27017/xyblog\\nJWT_SECRET=your_jwt_secret\\n```\\n\\n然后，在 `app.js` 文件的顶部确保加载 `dotenv`：\\n\\n```javascript\\nrequire('dotenv').config();\\n```\\n\\n## 启动服务器\\n\\n完成所有配置后，在终端中运行以下命令启动开发服务器：\\n\\n```bash\\nnpm run dev\\n```\\n\\n如果一切正常，你会在终端看到 `Server running on port 3000` 的输出，表示服务器已成功启动。现在，你可以在浏览器中访问 `http://localhost:3000` 并看到“xyblog Admin API Running”的消息，这表示你的服务器已启动并可以正常响应请求。\\n\\n## 总结\\n\\n到此为止，我们已经搭建了一个基于 Node.js、Express 和 MongoDB 的后台项目，并且成功启动了服务器。这是一个基本的项目结构，为后续的功能扩展提供了良好的基础。接下来可以继续完善 API 接口，实现更多功能。\\n\";","export default \"---\\ntitle: \\\"博客管理系统后端-项目搭建\\\"\\ndate: \\\"2024-11-08\\\"\\n---\\n\\n在本篇博客中，我们将详细介绍如何从零开始搭建一个基于 Node.js、Express 和 MongoDB 的后台项目。\\n本教程会以“xyblog-admin”项目为例，带领大家一步步完成基本的项目结构搭建、数据库连接、以及服务器启动。\\n\\n## 项目结构初始化\\n\\n1. 在项目目录（例如“xyblog-admin”）中，创建如下文件结构：\\n\\n   ```\\n   xyblog-admin\\n   ├── src\\n   │   ├── config          # 配置文件（如数据库连接）\\n   │   ├── controllers     # 控制器文件\\n   │   ├── middlewares     # 中间件\\n   │   ├── models          # 数据库模型\\n   │   ├── routes          # 路由\\n   │   └── utils           # 工具函数\\n   ├── .env                # 环境变量文件\\n   ├── app.js              # 项目主入口文件\\n   └── package.json        # Node.js 项目配置文件\\n   ```\\n\\n   这将帮助我们保持清晰的项目结构，便于后续扩展和维护。\\n\\n## 初始化 Node.js 项目\\n\\n1. 在项目根目录下，运行以下命令初始化 `package.json` 文件：\\n\\n   ```bash\\n   npm init -y\\n   ```\\n\\n2. 安装项目的主要依赖库：\\n\\n   ```bash\\n   npm install express mongoose dotenv jsonwebtoken bcryptjs cors\\n   ```\\n\\n3. 安装开发依赖（如 `nodemon` 用于开发环境的自动重启）：\\n\\n   ```bash\\n   npm install nodemon --save-dev\\n   ```\\n\\n4. 修改 `package.json` 文件，添加启动脚本：\\n\\n   ```json\\n   \\\"scripts\\\": {\\n       \\\"start\\\": \\\"node app.js\\\",\\n       \\\"dev\\\": \\\"nodemon app.js\\\"\\n   }\\n   ```\\n\\n## 配置主入口文件 app.js\\n\\n在根目录下创建 `app.js` 文件，配置 Express 服务器和 MongoDB 数据库连接。以下是 `app.js` 的基本配置：\\n\\n```javascript\\nconst express = require('express');\\nconst cors = require('cors');\\nconst mongoose = require('mongoose');\\nrequire('dotenv').config();\\n\\nconst app = express();\\nconst PORT = process.env.PORT || 5000;\\n\\napp.use(cors());\\napp.use(express.json());\\n\\n// 数据库连接\\nmongoose.connect(process.env.MONGODB_URI, {\\n    useNewUrlParser: true,\\n    useUnifiedTopology: true,\\n})\\n.then(() => console.log('MongoDB Connected'))\\n.catch((err) => console.log(err));\\n\\n// 基础路由测试\\napp.get('/', (req, res) => {\\n    res.send('xyblog Admin API Running');\\n});\\n\\napp.listen(PORT, () => {\\n    console.log(`Server running on port ${PORT}`);\\n});\\n```\\n\\n确保 `.env` 文件中定义了 `PORT` 和 `MONGODB_URI` 环境变量。\\n\\n## 创建 .env 文件\\n\\n在项目根目录下手动创建 `.env` 文件，配置以下内容：\\n\\n```plaintext\\nPORT=3000\\nMONGODB_URI=mongodb://localhost:27017/xyblog\\nJWT_SECRET=your_jwt_secret\\n```\\n\\n然后，在 `app.js` 文件的顶部确保加载 `dotenv`：\\n\\n```javascript\\nrequire('dotenv').config();\\n```\\n\\n## 启动服务器\\n\\n完成所有配置后，在终端中运行以下命令启动开发服务器：\\n\\n```bash\\nnpm run dev\\n```\\n\\n如果一切正常，你会在终端看到 `Server running on port 3000` 的输出，表示服务器已成功启动。现在，你可以在浏览器中访问 `http://localhost:3000` 并看到“xyblog Admin API Running”的消息，这表示你的服务器已启动并可以正常响应请求。\\n\\n## 总结\\n\\n到此为止，我们已经搭建了一个基于 Node.js、Express 和 MongoDB 的后台项目，并且成功启动了服务器。这是一个基本的项目结构，为后续的功能扩展提供了良好的基础。接下来可以继续完善 API 接口，实现更多功能。\\n\";","export default \"---\\ntitle: \\\"博文章管理 CRUD 实现\\\"\\ndate: \\\"2024-11-08\\\"\\n---\\n\\n本文档将详细总结个人博客管理系统后端中**文章管理的增删改查（CRUD）**功能。该功能使用户能够通过接口实现文章的创建、查询、更新和删除操作，并对用户身份进行验证。这是博客管理后台的核心功能之一。\\n\\n## 项目结构\\n\\n本节涉及的项目结构如下：\\n\\n```\\nproject-root\\n├── src\\n│   ├── models\\n│   │   └── Post.js          # 文章模型\\n│   ├── routes\\n│   │   └── post.js          # 文章管理路由\\n├── app.js                   # 主文件\\n```\\n\\n## 1. 文章模型定义\\n\\n首先在 `src/models/Post.js` 中定义文章模型。每篇文章包括标题、内容、作者和创建时间等字段。\\n\\n### Post.js 模型代码：\\n\\n```javascript\\n// src/models/Post.js\\nconst mongoose = require('mongoose');\\n\\nconst postSchema = new mongoose.Schema({\\n    title: { type: String, required: true },       // 文章标题\\n    content: { type: String, required: true },     // 文章内容\\n    author: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true }, // 作者引用\\n    createdAt: { type: Date, default: Date.now }   // 创建时间\\n});\\n\\nmodule.exports = mongoose.model('Post', postSchema);\\n```\\n\\n### 字段解释\\n\\n- **title**：文章的标题，必填字段。\\n- **content**：文章的内容，必填字段。\\n- **author**：引用用户模型 `User`，确保文章有明确的创建者。\\n- **createdAt**：文章的创建时间，默认为当前时间。\\n\\n## 2. 文章管理路由定义\\n\\n在 `src/routes/post.js` 中实现文章的增删改查接口，每个接口均为具体功能服务。\\n\\n### 路由文件 `post.js` 代码：\\n\\n```javascript\\nconst express = require('express');\\nconst auth = require('../middlewares/auth'); // 身份验证中间件\\nconst Post = require('../models/Post'); // 文章模型\\n\\nconst router = express.Router();\\n```\\n\\n### 2.1 创建文章接口\\n\\n通过此接口，经过身份验证的用户可以创建新文章。\\n\\n```javascript\\n// 创建文章接口\\nrouter.post('/create', auth, async (req, res) => {\\n    const { title, content } = req.body;\\n    const author = req.user.userId; // 从身份验证中间件获取用户ID\\n\\n    try {\\n        const post = new Post({ title, content, author });\\n        await post.save();\\n        res.status(201).json({ message: '文章创建成功', post });\\n    } catch (error) {\\n        res.status(500).json({ message: '文章创建失败', error });\\n    }\\n});\\n```\\n\\n#### 注意点\\n\\n- `auth` 中间件确保只有登录用户才能创建文章。\\n- `post.save()` 将新文章保存到数据库，成功后返回创建的文章信息。\\n\\n### 2.2 获取所有文章接口\\n\\n此接口用于获取数据库中的所有文章，主要用于展示文章列表。\\n\\n```javascript\\n// 获取所有文章\\nrouter.get('/', async (req, res) => {\\n    try {\\n        const posts = await Post.find().populate('author', 'username');\\n        res.json(posts);\\n    } catch (error) {\\n        res.status(500).json({ message: '获取文章失败', error });\\n    }\\n});\\n```\\n\\n#### 注意点\\n\\n- `Post.find()` 获取所有文章。\\n- `populate('author', 'username')` 用于展示文章作者的用户名，而不是作者 ID。\\n\\n### 2.3 获取单篇文章接口\\n\\n此接口根据文章 ID 返回具体文章内容，适用于文章详情页。\\n\\n```javascript\\n// 获取单篇文章\\nrouter.get('/:id', async (req, res) => {\\n    try {\\n        const post = await Post.findById(req.params.id).populate('author', 'username');\\n        if (!post) return res.status(404).json({ message: '文章未找到' });\\n        res.json(post);\\n    } catch (error) {\\n        res.status(500).json({ message: '获取文章失败', error });\\n    }\\n});\\n```\\n\\n#### 注意点\\n\\n- `Post.findById(req.params.id)` 通过文章 ID 获取特定文章。\\n- 如果文章不存在，返回 `404 Not Found` 错误。\\n\\n### 2.4 更新文章接口\\n\\n此接口允许文章作者更新自己的文章，非作者无权限更新。\\n\\n```javascript\\n// 更新文章\\nrouter.put('/:id', auth, async (req, res) => {\\n    const { title, content } = req.body;\\n\\n    try {\\n        const post = await Post.findOneAndUpdate(\\n            { _id: req.params.id, author: req.user.userId },\\n            { title, content },\\n            { new: true }\\n        );\\n        if (!post) return res.status(404).json({ message: '文章未找到或无权限更新' });\\n        res.json({ message: '文章更新成功', post });\\n    } catch (error) {\\n        res.status(500).json({ message: '更新文章失败', error });\\n    }\\n});\\n```\\n\\n#### 注意点\\n\\n- 使用 `auth` 中间件确保用户已登录。\\n- `findOneAndUpdate` 方法根据文章 ID 和作者 ID 更新文章，以确保只有作者可以更新。\\n\\n### 2.5 删除文章接口\\n\\n此接口允许文章作者删除自己的文章，非作者无权限删除。\\n\\n```javascript\\n// 删除文章\\nrouter.delete('/:id', auth, async (req, res) => {\\n    try {\\n        const post = await Post.findOneAndDelete({ _id: req.params.id, author: req.user.userId });\\n        if (!post) return res.status(404).json({ message: '文章未找到或无权限删除' });\\n        res.json({ message: '文章删除成功' });\\n    } catch (error) {\\n        res.status(500).json({ message: '删除文章失败', error });\\n    }\\n});\\n```\\n\\n#### 注意点\\n\\n- 使用 `auth` 中间件确保用户已登录。\\n- `findOneAndDelete` 方法根据文章 ID 和作者 ID 删除文章，确保只有作者可以删除。\\n\\n## 3. 总结\\n\\n通过以上增删改查（CRUD）接口的实现，个人博客管理系统的文章管理功能已基本完备，支持创建、查看、更新和删除文章。实现这些接口后，可以进一步扩展其他功能，例如分类管理、标签管理等，以完善博客管理后台。\\n\\n---\\n\\n本笔记涵盖了文章管理功能的实现细节，并通过具体代码提供了解决方案，便于后续复习和参考。\\n\";","export default \"---\\ntitle: \\\"文章管理系统开发笔记\\\"\\ndate: \\\"2024-11-08\\\"\\n---\\n\\n本笔记总结了从开发登录页面到文章管理系统的前端项目开发过程中的问题和注意事项。适合后续复习使用。\\n\\n---\\n\\n## 1. 登录页面开发\\n\\n- **问题**: 实现登录页面和后端接口的连接。\\n- **注意事项**:\\n  - 确保登录页面的表单字段与后端接口的字段保持一致。\\n  - 需要在Vue路由中设置默认重定向至登录页面，便于未授权用户直接跳转到登录界面。\\n  - 登录验证逻辑应放置在 `@submit` 方法中，以便在点击登录按钮时触发。\\n\\n## 2. 文章创建页面开发\\n\\n- **问题**: 实现文章创建页面以及与后端的交互。\\n- **注意事项**:\\n  - 在创建文章页面中需要包含标题、分类、标签和内容字段，并确保与后端字段匹配。\\n  - 在选择分类时，显示该分类的描述信息。\\n  - 使用Quill编辑器进行内容编辑，注意初始化Quill编辑器，并在内容提交时读取其内容。\\n\\n## 3. 文章管理页面开发\\n\\n- **问题**: 在文章管理页面中实现文章的增删改查功能。\\n- **注意事项**:\\n  - 使用表格显示所有文章的标题、分类和标签信息。\\n  - 为每篇文章添加编辑和删除按钮，确保删除时弹出确认提示。\\n  - 创建、标签管理、分类管理按钮要能跳转到相应页面。\\n\\n## 4. 标签管理页面开发\\n\\n- **问题**: 实现标签的增删改查功能，与后端接口交互。\\n- **注意事项**:\\n  - 添加标签管理页面，包括创建标签、更新标签名称、删除标签功能。\\n  - 在前端渲染中，需要确保标签名称的唯一性并处理编辑后的同步刷新。\\n\\n## 5. 分类管理页面开发\\n\\n- **问题**: 实现分类管理的增删改查功能，包含分类描述字段。\\n- **注意事项**:\\n  - 添加分类描述字段，并确保在前端和后端同步更新。\\n  - 确保分类的唯一性，并在创建或编辑时显示描述信息。\\n\\n## 6. 后端接口对接问题与注意事项\\n\\n- **问题**: 确保前后端接口对接顺畅，处理接口返回错误。\\n- **注意事项**:\\n  - 在前端页面中使用Axios处理HTTP请求，确保接口地址、方法和参数正确。\\n  - 捕获接口返回的错误信息，必要时在控制台或页面中显示，便于调试。\\n  - 在文章创建、编辑、删除等操作中，要验证分类和标签是否存在。\\n\\n## 7. 项目全局注意事项\\n\\n- **全局样式**: 确保各页面按钮、输入框样式统一，并保持交互一致性。\\n- **认证与权限**: 确保用户的登录状态和权限控制正确，限制未授权用户的访问。\\n- **代码结构**: 将项目分为清晰的模块（如：登录、文章管理、标签管理等），便于后续维护和扩展。\\n\\n---\\n\\n\";","<template>\n  <div id=\"app\">\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App'\n}\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>","import { render } from \"./App.vue?vue&type=template&id=8af8435a\"\nimport script from \"./App.vue?vue&type=script&lang=js\"\nexport * from \"./App.vue?vue&type=script&lang=js\"\n\nimport \"./App.vue?vue&type=style&index=0&id=8af8435a&lang=css\"\n\nimport exportComponent from \"../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n  <div class=\"rounded-bg\">\n    <h1 class=\"title\">强风吹拂，聚散流云</h1>\n  </div>\n  <div class=\"bottom-rounded-bg\">\n    <h2 class=\"blog-title\">sunduskxy</h2>\n    <ul class=\"blog-list\">\n      <li\n        class=\"blog-item\"\n        v-for=\"(blog, index) in paginatedBlogs\"\n        :key=\"index\"\n        @click=\"goToBlog(blog.id)\"\n      >\n        <h3>{{ blog.title }}</h3>\n        <div v-html=\"getTruncatedContent(blog.content)\" class=\"blog-content\"></div>\n        <div class=\"blog-title-container\">\n          <img src=\"@/assets/riqi.png\" alt=\"日期图标\" class=\"date-icon\" />\n          <p class=\"blog-title-content\">{{ blog.date }}</p>\n        </div>\n      </li>\n    </ul>\n    <div class=\"pagination\">\n      <button @click=\"changePage(currentPage - 1)\" :disabled=\"currentPage === 1\">上一页</button>\n      <span>第 {{ currentPage }} 页，共 {{ totalPages }} 页</span>\n      <button @click=\"changePage(currentPage + 1)\" :disabled=\"currentPage === totalPages\">下一页</button>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { marked } from 'marked';\nimport yaml from 'js-yaml';\n\nexport default {\n  name: 'XYHome',\n  data() {\n    return {\n      blogs: [],\n      currentPage: 1,\n      pageSize: 10,\n      contentLimit: 150,\n    };\n  },\n  computed: {\n    totalPages() {\n      return Math.ceil(this.blogs.length / this.pageSize);\n    },\n    paginatedBlogs() {\n      const start = (this.currentPage - 1) * this.pageSize;\n      return this.blogs.slice(start, start + this.pageSize);\n    },\n  },\n  methods: {\n    loadBlogs() {\n      try {\n        const context = require.context('@/posts', false, /\\.md$/);\n        const blogs = context.keys().map((key) => {\n          const markdownContent = context(key).default;\n\n          const yamlFrontMatterMatch = markdownContent.match(/---\\s*([\\s\\S]*?)\\s*---/);\n          let metadata = { date: '未知日期', title: '未知标题' };\n\n          if (yamlFrontMatterMatch) {\n            const yamlContent = yamlFrontMatterMatch[1];\n            metadata = yaml.load(yamlContent);\n          }\n\n          const renderedContent = marked(markdownContent.replace(/---\\s*([\\s\\S]*?)\\s*---/, ''));\n\n          return {\n            id: key.slice(2, -3),\n            title: metadata.title || '未知标题',\n            content: renderedContent,\n            date: metadata.date || '未知日期',\n          };\n        });\n\n        // 按日期排序，最近的日期在前\n        this.blogs = blogs.sort((a, b) => new Date(b.date) - new Date(a.date));\n      } catch (error) {\n        console.error('加载博客文章时出错:', error);\n      }\n    },\n    goToBlog(blogId) {\n      this.$router.push({ name: 'XYBlogDetail', params: { id: blogId } });\n    },\n    changePage(page) {\n      if (page >= 1 && page <= this.totalPages) {\n        this.currentPage = page;\n        window.scrollTo({ top: 0, behavior: 'smooth' });\n      }\n    },\n    getTruncatedContent(content) {\n      const plainText = content.replace(/(<([^>]+)>)/gi, '');\n      if (plainText.length > this.contentLimit) {\n        return marked(plainText.slice(0, this.contentLimit) + '...');\n      }\n      return content;\n    },\n  },\n  mounted() {\n    this.loadBlogs();\n  },\n};\n</script>\n\n<style>\n.rounded-bg {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 400px;\n  background-image: url('@/assets/whiteBC.jpg');\n  background-size: cover;\n}\n\n.title {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  font-size: 50px;\n  color: #333;\n}\n\n.bottom-rounded-bg {\n  margin: 400px 80px 150px 80px;\n  height: auto;\n  padding: 20px;\n  background-color: #444;\n  border-radius: 20px;\n}\n\n.blog-title {\n  font-size: 24px;\n  margin-bottom: 20px;\n  color: #fff;\n}\n\n.blog-list {\n  list-style: none;\n  padding: 0;\n}\n\n.blog-item {\n  background-color: #333;\n  border-radius: 10px;\n  padding: 15px;\n  margin-bottom: 15px;\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n  cursor: pointer;\n  transition: background-color 0.3s ease;\n}\n\n.blog-item:hover {\n  background-color: #555;\n}\n\n.blog-item h3 {\n  font-size: 20px;\n  color: #fff;\n}\n\n.blog-content {\n  color: #fff;\n  text-align: left;\n}\n\n.blog-item div.blog-content {\n  display: -webkit-box;\n  -webkit-line-clamp: 3;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.blog-title-container {\n  display: flex;\n  align-items: center;\n  margin-top: 10px;\n  color: #bbb;\n}\n\n.date-icon {\n  width: 16px;\n  height: 16px;\n  margin-right: 5px;\n}\n\n.blog-title-content {\n  margin: 0;\n  font-size: 14px;\n}\n\n.pagination {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-top: 60px;\n}\n\n.pagination button {\n  background-color: #333;\n  color: #fff;\n  border: none;\n  padding: 10px 20px;\n  border-radius: 5px;\n  cursor: pointer;\n  transition: background-color 0.3s ease;\n}\n\n.pagination button:disabled {\n  background-color: #888;\n  cursor: not-allowed;\n}\n\n.pagination button:hover:not(:disabled) {\n  background-color: #555;\n}\n\n.pagination span {\n  color: #fff;\n}\n</style>","import { render } from \"./XYHome.vue?vue&type=template&id=3e61ba1b\"\nimport script from \"./XYHome.vue?vue&type=script&lang=js\"\nexport * from \"./XYHome.vue?vue&type=script&lang=js\"\n\nimport \"./XYHome.vue?vue&type=style&index=0&id=3e61ba1b&lang=css\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","<template>\n  <div class=\"blog-detail\">\n    <div class=\"header-image\">\n      <h1>{{ blogTitle }}</h1>\n      <p class=\"blog-date\">{{ blogDate }}</p> <!-- 显示博客创建时间 -->\n    </div>\n    <div class=\"content-card\" v-html=\"blogContent\"></div>\n  </div>\n</template>\n\n<script>\nimport { marked } from 'marked';\nimport yaml from 'js-yaml';\n\nexport default {\n  name: 'XYBlogDetail',\n  data() {\n    return {\n      blogTitle: '',\n      blogContent: '',\n      blogDate: '', // 博客创建日期\n    };\n  },\n  created() {\n    const blogId = this.$route.params.id;\n    this.fetchBlogContent(blogId);\n  },\n  methods: {\n    fetchBlogContent(blogId) {\n      const context = require.context('@/posts', false, /\\.md$/);\n      const blogKey = `./${blogId}.md`;\n\n      if (context.keys().includes(blogKey)) {\n        const markdownContent = context(blogKey).default;\n\n        // 提取 YAML front matter\n        const yamlFrontMatterMatch = markdownContent.match(/---\\s*([\\s\\S]*?)\\s*---/);\n        let metadata = { date: '未知日期', title: '未知标题' };\n\n        if (yamlFrontMatterMatch) {\n          const yamlContent = yamlFrontMatterMatch[1];\n          // 使用 js-yaml 解析 YAML 内容\n          metadata = yaml.load(yamlContent);\n        }\n\n        this.blogTitle = metadata.title || '未知标题'; // 从 YAML 中获取标题\n        this.blogContent = marked(markdownContent.replace(/---\\s*([\\s\\S]*?)\\s*---/, '')); // 渲染Markdown内容\n        this.blogDate = metadata.date || '未知日期'; // 从 YAML 中获取日期\n      } else {\n        this.blogTitle = '博客未找到';\n        this.blogContent = '抱歉，没有找到您请求的博客内容。';\n        this.blogDate = ''; // 未找到博客时清空日期\n      }\n    },\n  },\n};\n</script>\n\n<style>\n.blog-detail {\n  padding: 0;\n  background-color: #fff;\n  color: #333;\n}\n\n.header-image {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 600px;\n  background-image: url('@/assets/whiteBC.jpg');\n  background-size: cover;\n  text-align: center; /* 使标题和日期居中 */\n}\n\n.header-image h1 {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  font-size: 50px;\n  color: #333;\n}\n\n.blog-date {\n  position: absolute;\n  top: 65%; /* 日期位置略低于标题 */\n  left: 50%;\n  transform: translate(-50%, -50%);\n  font-size: 20px;\n  color: #0b0b0b; /* 日期颜色 */\n}\n\n.content-card {\n  margin-top: 600px;\n  padding: 100px; /* 调整内容与卡片边框的内边距 */\n  margin-left: 300px; /* 增加卡片左右间距 */\n  margin-right: 300px; /* 增加卡片左右间距 */\n  margin-bottom: 20px;\n  background-color: #444;\n  color: #fff;\n  border-radius: 20px;\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n  position: relative;\n  top: -100px;\n  text-align: left; /* 内容左对齐 */\n}\n</style>","import { render } from \"./XYBlogDetail.vue?vue&type=template&id=4ebe91e2\"\nimport script from \"./XYBlogDetail.vue?vue&type=script&lang=js\"\nexport * from \"./XYBlogDetail.vue?vue&type=script&lang=js\"\n\nimport \"./XYBlogDetail.vue?vue&type=style&index=0&id=4ebe91e2&lang=css\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","// src/router/index.js\nimport { createRouter, createWebHashHistory } from 'vue-router'\nimport XYHome from '@/components/XYHome.vue'\nimport XYBlogDetail from '@/components/XYBlogDetail.vue'\n\nconst routes = [\n  {\n    path: '/',\n    name: 'XYHome',\n    component: XYHome\n  },\n  {\n    path: '/blog/:id',\n    name: 'XYBlogDetail',\n    component: XYBlogDetail\n  }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router","import { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\n\nconst app = createApp(App)\n\n// 使用 router\napp.use(router)\n\napp.mount('#app')","var map = {\n\t\"./JavaScript后端使用-创建API.md\": 4729,\n\t\"./Python简单的开发流程.md\": 1142,\n\t\"./Vue 组件全局样式和作用域问题：避免页面上下出现白色间隔.md\": 2072,\n\t\"./Vue笔记-注册路由跳转.md\": 1940,\n\t\"./Vue笔记-项目创建.md\": 7041,\n\t\"./macOS下本地 MongoDB 安装、启动及项目集成指南.md\": 1013,\n\t\"./分类和标签管理实现总结.md\": 1517,\n\t\"./博客管理系统后端-注册、登录、令牌.md\": 8069,\n\t\"./博客管理系统后端-项目搭建.md\": 5947,\n\t\"./博文章管理 CRUD 实现.md\": 9530,\n\t\"./文章管理系统开发笔记.md\": 2749\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 653;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t524: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkmy_blog\"] = self[\"webpackChunkmy_blog\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [504], function() { return __webpack_require__(9229); })\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["id","_createElementBlock","_hoisted_1","_createVNode","_component_router_view","name","__exports__","render","class","_Fragment","_createElementVNode","_hoisted_2","_renderList","$options","paginatedBlogs","blog","index","key","onClick","$event","goToBlog","_toDisplayString","title","innerHTML","getTruncatedContent","content","_hoisted_4","_hoisted_5","src","_imports_0","alt","_hoisted_6","date","_hoisted_3","_hoisted_7","_cache","changePage","$data","currentPage","disabled","_hoisted_8","totalPages","_hoisted_9","data","blogs","pageSize","contentLimit","computed","Math","ceil","this","length","start","slice","methods","loadBlogs","context","require","keys","map","markdownContent","default","yamlFrontMatterMatch","match","metadata","yamlContent","yaml","renderedContent","marked","replace","sort","a","b","Date","error","console","blogId","$router","push","params","page","window","scrollTo","top","behavior","plainText","mounted","blogTitle","blogDate","blogContent","created","$route","fetchBlogContent","blogKey","includes","routes","path","component","XYHome","XYBlogDetail","router","createRouter","history","createWebHashHistory","app","createApp","App","use","mount","webpackContext","req","webpackContextResolve","__webpack_require__","o","e","Error","code","Object","resolve","module","exports","__webpack_module_cache__","moduleId","cachedModule","undefined","__webpack_modules__","call","m","deferred","O","result","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","every","splice","r","n","getter","__esModule","d","definition","defineProperty","enumerable","get","g","globalThis","Function","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","value","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","self","forEach","bind","__webpack_exports__"],"sourceRoot":""}