(function(){var n={4729:function(n,e,t){"use strict";t.r(e),e["default"]="---\ntitle: \"JavaScript后端使用-创建API\"\ndate: \"2024-10-30\"\n---\n\n一、项目创建与环境配置\n\n1. 初始化Node.js项目\n   后端的基础是Node.js，而Express则是一个轻量级的Web框架，可以快速构建API接口。下面是我创建一个Node.js项目的基本步骤：\n\n2. 安装Node.js： 如果你还没有安装Node.js，可以去 Node.js官网 下载并安装。\n\n3. 创建项目文件夹并初始化项目：\n   首先，进入项目文件夹并使用 npm init 初始化项目，生成 package.json 文件：\n\n   ```\n   mkdir blog-backend\n   cd blog-backend\n   npm init -y\n   ```\n\n   其中，`-y` 参数可以跳过一系列手动配置，快速生成 `package.json`。\n\n4. 安装必要依赖：\n   接下来，我安装了后端所需的依赖，包括 `express`（用于构建Web服务器）和 `cors`（用于解决跨域问题）：\n\n   ```\n   npm install express cors\n   ```\n\n5. 创建基础Express服务器\n\n完成环境配置后，我开始编写最基本的Express服务器代码。这是我的 `server.js` 文件内容：\n\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst app = express();\n\napp.use(cors()); // 允许跨域请求\n\n// 定义一个简单的API返回动态标题\napp.get('/api/title', (req, res) => {\n  const title = '强风吹拂，聚散流云';\n  res.json({ title });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});\n```\n\nExpress框架： 用于快速创建一个可以处理HTTP请求的Web服务器。\nCORS中间件： 用来解决前后端不同源之间的跨域问题。\n基本API： 我定义了 /api/title 路由，向前端返回一个简单的标题，接下来会通过前端Axios请求这个数据并展示出来。\n\n3. 启动服务器\n   通过以下命令来启动Express服务器：\n\n```\nnode server.js\n```\n\n服务器启动后，控制台会输出 `Server running on http://localhost:3000`，表示后端服务已经准备好。\n\n---\n\n二、前后端的联动\n\n1. 用Axios从后端获取数据\n\n为了将后端的数据展示在前端，我使用了 `axios` 库。Axios可以很方便地向后端API发送请求，并获取返回的数据。以下是我如何在前端通过Axios获取后端提供的标题，并在页面中展示的代码：\n\n```javascript\nloadTitle() {\n  axios.get('http://localhost:3000/api/title')\n    .then(response => {\n      this.pageTitle = response.data.title;\n    })\n    .catch(error => {\n      console.error('获取标题时出错:', error);\n    });\n}\n```\n\nAxios请求： 请求 `/api/title` 路由，获取标题数据并将其赋值给前端的 `pageTitle`。\n错误处理： 如果请求失败，将在控制台输出错误信息。\n\n2. 实现动态背景图\n\n接下来，我实现了从后端获取背景图片的功能。为了更好地管理图片，我将图片上传到了GitHub仓库，然后通过后端API将图片URL返回给前端，动态设置背景图。\n\n后端API代码：\n\n```javascript\napp.get('/api/background', (req, res) => {\n  const backgroundImageUrl = 'https://raw.githubusercontent.com/sundusk/blogBackImage/main/one.png';\n  res.json({ backgroundImage: backgroundImageUrl });\n});\n```\n\n前端通过Axios获取背景图URL，并将其设置为页面背景：\n\n```javascript\nloadBackgroundImage() {\n  axios.get('http://localhost:3000/api/background')\n    .then(response => {\n      document.querySelector('.rounded-bg').style.backgroundImage = `url(${response.data.backgroundImage})`;\n    })\n    .catch(error => {\n      console.error('获取背景图时出错:', error);\n    });\n}\n```\n\n这样，前端的背景图片可以动态地从后端获取，增强了项目的灵活性。\n\n---\n\n三、优化开发流程\n\n1. 引入Nodemon自动重启\n\n在开发过程中，我发现每次修改后端代码都需要手动重启服务器，这非常影响开发效率。于是，我引入了 `nodemon` 这个工具，它可以在检测到代码变动时自动重启服务器。\n\n使用以下命令安装 `nodemon`：\n\n```bash\nsudo npm install -g nodemon\n```\n\n安装成功后，我用以下命令启动服务器，代替原来的 `node` 命令：\n\n```bash\nnodemon server.js\n```\n\nNodemon会监控项目中的文件变化，自动重启服务器，大大提高了开发效率。\n\n2. GitHub作为资源管理器\n\n在全栈开发中，图片资源的管理是非常重要的。为此，我将图片资源上传至GitHub仓库，并通过GitHub的外链进行管理。在后端API中直接返回图片的URL，这不仅解决了存储问题，还提升了加载效率。\n\n---\n\n四、项目架构与代码结构的思考\n\n在项目开发过程中，我也逐渐意识到代码组织的重要性。随着项目的不断增大，代码的清晰性和可维护性变得越来越重要。因此，我开始尝试将项目模块化，遵循RESTful设计原则，将不同功能的API拆分到各自的路由模块中。\n\n1. 将路由拆分\n   我将不同的功能模块分开管理，创建不同的路由文件。例如，专门创建 `titleRouter.js` 和 `backgroundRouter.js` 来处理不同的API请求：\n\n`titleRouter.js`：\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\nrouter.get('/', (req, res) => {\n  const title = '强风吹拂，聚散流云';\n  res.json({ title });\n});\n\nmodule.exports = router;\n```\n\n`backgroundRouter.js`：\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\nrouter.get('/', (req, res) => {\n  const backgroundImageUrl = 'https://raw.githubusercontent.com/sundusk/blogBackImage/main/one.png';\n  res.json({ backgroundImage: backgroundImageUrl });\n});\n\nmodule.exports = router;\n```\n\n这样做有助于让代码更加清晰、易于维护，同时也方便日后扩展更多的API功能。"},1142:function(n,e,t){"use strict";t.r(e),e["default"]='---\ntitle: "Python简单的开发流程"\ndate: "2024-10-25"\n---\n\n### 一切建立在Mac环境配置完成之后，使用VSCode  \n#### 1.创建项目名.py\n```\nmkdir MyPythonProject\ncd MyPythonProject\n```\n#### 2.创建虚拟环境\n之所以要创建虚拟环境，是因为各个项目的环境配置是不一样的，为了避免之后的新建项目的环境冲突，方便管理项目的依赖\n创建虚拟环境命令行\n```\npython3 -m venv venv\n```\n激活虚拟环境命令行\n```\nsource venv/bin/activate\n```\n\n#### 3.安装依赖\n使用pip安装所需第三方库\n例如\n```\npip install requests \n```\n\n\n#### 4.编写代码\n#### 5.运行代码\n```\npython newOne.py\n```\n#### 6.创建可执行文件（Mac应用程序）\n如果希望生成一个Mac应用程序包（.app），可以使用以下命令：\n```\npyinstaller --onefile --windowed newOne.py\n```\n\n#### 7.清理并关闭虚拟环境\n在完成开发后，激活的虚拟环境是需要关闭的\n```\ndeactivate\n```\n'},2072:function(n,e,t){"use strict";t.r(e),e["default"]='---\ntitle: "Vue 组件全局样式和作用域问题：避免页面上下出现白色间隔"\ndate: "2024-11-08"\n---\n\n在使用 Vue.js 进行开发时，我们经常会遇到样式作用范围的问题。尤其是在设置页面的背景颜色时，如果没有正确处理全局样式，可能会导致页面上下出现不需要的白色间隔。本文将通过一个具体的例子来说明如何避免这种情况。\n\n## 问题描述\n\n假设我们有一个 `UserLogin.vue` 文件，它定义了一个简单的登录页面，我们希望页面的背景颜色是黑色。但在实际渲染时，页面上下却出现了白色的间隔。如下是可能导致该问题的代码示例：\n\n```vue\n<template>\n  <div class="user-login">\n    <h1>登录</h1>\n    <p>这是一个基本的用户登录页面。</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "UserLogin",\n};\n<\/script>\n\n<style scoped>\n.user-login {\n  background-color: black;\n  color: white; /* 设置文字颜色为白色 */\n  height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n}\n</style>\n```\n\n### 问题分析\n\n在 Vue 组件中，使用 `<style scoped>` 会让样式只作用于当前组件的 HTML 结构内部，而不会影响到整个页面的 `html` 和 `body` 元素。因此，上述代码虽然设置了 `.user-login` 的背景颜色，但并没有覆盖到全局的 `html` 和 `body`，导致页面上下出现了白色区域。\n\n### 解决方法\n\n为了确保背景颜色在整个页面中一致，我们可以通过以下方法来解决这个问题：\n\n1. **在根组件或全局样式文件中定义 `html` 和 `body` 的样式**。通过全局应用样式，我们可以确保整个页面的布局和背景颜色保持一致。\n\n2. **去掉 `scoped`，直接在 `UserLogin.vue` 中定义 `html` 和 `body` 的样式**。\n\n以下是修改后的 `UserLogin.vue` 代码：\n\n```vue\n<template>\n  <div class="user-login">\n    <h1>登录</h1>\n    <p>这是一个基本的用户登录页面。</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "UserLogin",\n};\n<\/script>\n\n<style lang="scss">\n/* 全局设置 html 和 body 样式 */\nhtml,\nbody {\n  margin: 0;\n  padding: 0;\n  background-color: black;\n  color: white;\n  height: 100%; /* 确保占满全屏 */\n}\n\n.user-login {\n  height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n}\n</style>\n```\n\n### 总结\n\n通过直接设置 `html` 和 `body` 的全局样式，可以确保整个页面的背景色和布局一致，从而避免顶部和底部出现白色间隔。这种方式不会因为 `scoped` 限制作用域而影响整体布局效果。\n\n希望这个方法能帮助你在 Vue 项目中更好地控制页面样式。如果以后遇到类似的问题，可以检查是否是 `scoped` 样式导致的问题，并选择合适的方式将样式作用到全局。\n\n---\n\n**参考：**\n\n- [Vue.js 官方文档 - Scoped 样式](https://vuejs.org/guide/scoped-styles.html)\n'},1940:function(n,e,t){"use strict";t.r(e),e["default"]="---\ntitle: \"Vue笔记-注册路由跳转\"\ndate: \"2024-10-25\"\n---\n\n### 项目结构\n\n```\nsrc/\n  components/\n    HelloWorld.vue\n    NewOneComponent.vue\n  router/\n    index.js\n  App.vue\n  main.js\n```\n\n### 一、安装Vue Router\n\n首先，确保项目中已安装 Vue Router。如果没有安装，可以使用以下命令安装：\n\n```终端\nnpm install vue-router@next\n```\n\n### 二、创建路由配置文件\n\n在 src 目录下创建一个 router 文件夹，并在其中创建一个 index.js 文件，定义路由配置：\n\n```javascript\n// src/router/index.js\nimport { createRouter, createWebHistory } from 'vue-router';\nimport HelloWorld from '../components/HelloWorld.vue';\nimport NewOneComponent from '../components/NewOneComponent.vue';\n\nconst routes = [\n  { path: '/', component: HelloWorld },\n  { path: '/NewOneComponent', component: NewOneComponent }\n];\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes\n});\n\nexport default router;\n```\n\n### 三、在 main.js 中引入并使用路由\n\n在 main.js 文件中引入并使用路由：\n\n```javascript\n// src/main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nimport router from './router';\n\ncreateApp(App).use(router).mount('#app');\n```\n\n### 四、配置主组件以支持路由视图\n\n在 App.vue 文件中添加 <router-view> 标签，用于显示匹配的路由组件：\n\n```javascript\n\x3c!-- src/App.vue --\x3e\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\">\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App'\n}\n<\/script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n```\n\n### 五、配置要跳转的组件\n\n在 HelloWorld.vue 组件中添加按钮和点击事件，以实现页面跳转：\n\n```javascript\n<template>\n  <div>\n    这是新的初始页面\n    <button @click=\"goToNewPage\">跳转到 NewOne 页面</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'HelloWorld',\n  methods: {\n    goToNewPage() {\n      this.$router.push('/NewOneComponent');\n    }\n  }\n}\n<\/script>\n```\n\n### 六、确保跳转目标组件存在并正确配置\n\n```javascript\n\x3c!-- src/components/NewOneComponent.vue --\x3e\n<template>\n  <div>\n    这是个网页哦\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'NewOneComponent'\n}\n<\/script>\n```\n\n配置完成后，开启本地服务器运行项目，查看是否正常\n"},7041:function(n,e,t){"use strict";t.r(e),e["default"]='---\ntitle: "Vue笔记-项目创建"\ndate: "2024-10-25"\n---\n\n### 创建vue项目\n\n1.在配置环境完成之后，在终端运行指令创建项目\n\n`vue create my-project`\n\n2.运行项目，在终端中输入命令行来启动服务器\n\n`npm run serve`\n\n### Vue目录结构\n\n| 目录/文件    | 说明                                                         |\n| :----------- | :----------------------------------------------------------- |\n| build        | 项目构建(webpack)相关代码                                    |\n| config       | 配置目录，包括端口号等。我们初学可以使用默认的。             |\n| node_modules | npm 加载的项目依赖模块                                       |\n| src          | 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件。 |\n| static       | 静态资源目录，如图片、字体等。                               |\n| test         | 初始测试目录，可删除                                         |\n| .xxxx文件    | 这些是一些配置文件，包括语法配置，git配置等。                |\n| index.html   | 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。       |\n| package.json | 项目配置文件。                                               |\n| README.md    | 项目的说明文档，markdown 格式                                |\n\n也就是说，正常开发的时候，在src文件夹中进行新的组件的创建\n\n### 创建基本组件结构\n\n要在新的组件页面编写代码，如下是基本的组件结构\n\n```\n<template>\n  <div class="hello">\n    \x3c!-- 这里是模板内容 --\x3e\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'HelloWorld\',\n  data() {\n    return {\n      // 这里是组件的数据\n    }\n  },\n  methods: {\n    // 这里是组件的方法\n  }\n}\n<\/script>\n\n<style scoped>\n.hello {\n  /* 这里是组件的样式 */\n}\n</style>\n```\n\n### 项目完成之后\n\n1.构建项目\n\n在项目的根目录下运行以下终端命令行，将vue,js应用构建为静态文件\n\n`npm run build`\n\n2.配置项目（这个是可选的）\n\n如果需要自定义构建配置，可以在vue.config.js文件中进行配置。例如，如果要将应用部署到子路径，可以这样配置：\n\n```\nmodule.exports = {\n\tpublicPath: \'/my-app/\'\n}\n```\n\n3.部署到Web服务器\n'},1013:function(n,e,t){"use strict";t.r(e),e["default"]="---\ntitle: \"macOS下本地 MongoDB 安装、启动及项目集成指南\"\ndate: \"2024-10-31\"\n---\n\n本文详细介绍了如何在 macOS 上使用 Homebrew 安装 MongoDB 社区版，启动本地 MongoDB 服务，并通过 Node.js 项目进行数据库集成。\n\n## 一、安装 MongoDB 社区版\n\n1. **更新 Homebrew：**\n\n   ```bash\n   brew update\n   ```\n\n2. **添加 MongoDB 官方 Tap：**\n\n   ```bash\n   brew tap mongodb/brew\n   ```\n\n3. **安装 MongoDB 社区版：**\n\n   ```bash\n   brew install mongodb/brew/mongodb-community@7.0\n   ```\n\n## 二、启动 MongoDB 服务\n\n- 启动 MongoDB 服务：\n\n  ```bash\n  brew services start mongodb/brew/mongodb-community@7.0\n  ```\n\n- 检查服务状态，确保 MongoDB 已成功启动：\n\n  ```bash\n  brew services list\n  ```\n\n### 连接到 MongoDB Shell\n\n使用以下命令进入 MongoDB Shell 进行交互：\n\n```bash\nmongo\n```\n\n### 停止 MongoDB 服务\n\n如需停止服务，可使用以下命令：\n\n```bash\nbrew services stop mongodb/brew/mongodb-community@7.0\n```\n\n## 三、Node.js 项目中的 MongoDB 集成\n\n1. **安装 Mongoose：**\n   在 Node.js 项目中，使用 Mongoose 库连接 MongoDB。\n\n   ```bash\n   npm install mongoose\n   ```\n\n2. **配置数据库连接**\n   在项目的 `server.js` 中配置 Mongoose 连接：\n\n   ```javascript\n   const mongoose = require('mongoose');\n   mongoose.connect('mongodb://localhost:27017/myBlog', {\n     useNewUrlParser: true,\n     useUnifiedTopology: true,\n   });\n   const db = mongoose.connection;\n   db.on('error', console.error.bind(console, 'MongoDB 连接错误:'));\n   db.once('open', () => {\n     console.log('成功连接到 MongoDB');\n   });\n   ```\n\n3. **创建数据模型**\n   在项目中定义博客文章的 Schema，例如在 `models/Blog.js` 文件中：\n\n   ```javascript\n   const mongoose = require('mongoose');\n   const blogSchema = new mongoose.Schema({\n     title: { type: String, required: true },\n     content: { type: String, required: true },\n     date: { type: Date, default: Date.now },\n   });\n   const Blog = mongoose.model('Blog', blogSchema);\n   module.exports = Blog;\n   ```\n\n## 四、设置 API 路由\n\n在 Express 项目中创建和获取博客文章的 API 路由：\n\n```javascript\nconst express = require('express');\nconst Blog = require('./models/Blog');\nconst app = express();\napp.use(express.json());\n\n// 创建新的博客文章\napp.post('/api/blog', async (req, res) => {\n  try {\n    const newBlog = new Blog(req.body);\n    await newBlog.save();\n    res.json({ message: '博客文章创建成功' });\n  } catch (error) {\n    res.status(500).json({ error: '创建博客文章时出错' });\n  }\n});\n\n// 获取所有博客文章\napp.get('/api/blogs', async (req, res) => {\n  try {\n    const blogs = await Blog.find();\n    res.json(blogs);\n  } catch (error) {\n    res.status(500).json({ error: '获取博客列表时出错' });\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));\n```\n\n## 五、常见问题及排查\n\n1. **`req.body` 是 undefined**  \n   - 解决：确保 `app.use(express.json())` 在路由之前添加，并在请求时选择 `Content-Type` 为 `application/json`。\n\n2. **连接 MongoDB 时报错**  \n   - 解决：确保 MongoDB 服务已启动，可通过 `brew services list` 查看。\n\n通过以上步骤，您已成功在 macOS 上安装并配置 MongoDB，并将其集成到 Node.js 项目中。\n"},1517:function(n,e,t){"use strict";t.r(e),e["default"]="---\ntitle: \"分类和标签管理实现总结\"\ndate: \"2024-11-08\"\n---\n\n本文档将总结个人博客管理系统后端中 **分类和标签管理** 功能的实现过程。分类和标签帮助我们对文章进行更细致的组织和筛选，是博客管理的重要组成部分。\n\n## 项目结构\n\n在实现分类和标签管理功能后，项目结构如下：\n\n```\nproject-root\n├── src\n│   ├── models\n│   │   ├── Category.js       # 分类模型\n│   │   └── Tag.js            # 标签模型\n│   ├── routes\n│   │   ├── category.js       # 分类管理路由\n│   │   └── tag.js            # 标签管理路由\n├── app.js                    # 主文件\n└── ...\n```\n\n## 1. 分类模型定义\n\n在 `src/models/Category.js` 中定义分类模型。每个分类包含名称和描述字段，名称字段需要唯一，以便区分不同分类。\n\n```javascript\n// src/models/Category.js\nconst mongoose = require('mongoose');\n\nconst categorySchema = new mongoose.Schema({\n    name: { type: String, required: true, unique: true },  // 分类名称，必填且唯一\n    description: { type: String }                           // 分类描述，可选\n});\n\nmodule.exports = mongoose.model('Category', categorySchema);\n```\n\n### 字段解释\n\n- **name**：分类的名称，必填且唯一，用于区分不同的分类。\n- **description**：分类的描述，可以为每个分类提供额外说明和信息，可选字段。\n\n---\n\n## 2. 标签模型定义\n\n在 `src/models/Tag.js` 中定义标签模型。标签模型仅包含名称字段，且名称字段唯一，确保每个标签能够独立标识。\n\n```javascript\n// src/models/Tag.js\nconst mongoose = require('mongoose');\n\nconst tagSchema = new mongoose.Schema({\n    name: { type: String, required: true, unique: true }    // 标签名称，必填且唯一\n});\n\nmodule.exports = mongoose.model('Tag', tagSchema);\n```\n\n### 字段解释\n\n- **name**：标签的名称，必填且唯一，用于标识和区分不同标签。\n\n---\n\n## 3. 分类和标签路由定义\n\n### 分类路由：`category.js`\n\n在 `src/routes/category.js` 中创建分类的增删改查（CRUD）接口，确保用户通过这些接口管理分类内容。\n\n```javascript\nconst express = require('express');\nconst auth = require('../middlewares/auth');  // 仅授权用户可以管理分类\nconst Category = require('../models/Category');\n\nconst router = express.Router();\n\n// 创建分类\nrouter.post('/create', auth, async (req, res) => {\n    const { name, description } = req.body;\n\n    try {\n        const category = new Category({ name, description });\n        await category.save();\n        res.status(201).json({ message: '分类创建成功', category });\n    } catch (error) {\n        res.status(500).json({ message: '分类创建失败', error });\n    }\n});\n\n// 获取所有分类\nrouter.get('/', async (req, res) => {\n    try {\n        const categories = await Category.find();\n        res.json(categories);\n    } catch (error) {\n        res.status(500).json({ message: '获取分类失败', error });\n    }\n});\n\n// 更新分类\nrouter.put('/:id', auth, async (req, res) => {\n    const { name, description } = req.body;\n\n    try {\n        const category = await Category.findByIdAndUpdate(\n            req.params.id,\n            { name, description },\n            { new: true }\n        );\n        if (!category) return res.status(404).json({ message: '分类未找到' });\n        res.json({ message: '分类更新成功', category });\n    } catch (error) {\n        res.status(500).json({ message: '更新分类失败', error });\n    }\n});\n\n// 删除分类\nrouter.delete('/:id', auth, async (req, res) => {\n    try {\n        const category = await Category.findByIdAndDelete(req.params.id);\n        if (!category) return res.status(404).json({ message: '分类未找到' });\n        res.json({ message: '分类删除成功' });\n    } catch (error) {\n        res.status(500).json({ message: '删除分类失败', error });\n    }\n});\n\nmodule.exports = router;\n```\n\n### 标签路由：`tag.js`\n\n在 `src/routes/tag.js` 中创建标签的增删改查（CRUD）接口，使用户能够管理标签内容。\n\n```javascript\nconst express = require('express');\nconst auth = require('../middlewares/auth');\nconst Tag = require('../models/Tag');\n\nconst router = express.Router();\n\n// 创建标签\nrouter.post('/create', auth, async (req, res) => {\n    const { name } = req.body;\n\n    try {\n        const tag = new Tag({ name });\n        await tag.save();\n        res.status(201).json({ message: '标签创建成功', tag });\n    } catch (error) {\n        res.status(500).json({ message: '标签创建失败', error });\n    }\n});\n\n// 获取所有标签\nrouter.get('/', async (req, res) => {\n    try {\n        const tags = await Tag.find();\n        res.json(tags);\n    } catch (error) {\n        res.status(500).json({ message: '获取标签失败', error });\n    }\n});\n\n// 更新标签\nrouter.put('/:id', auth, async (req, res) => {\n    const { name } = req.body;\n\n    try {\n        const tag = await Tag.findByIdAndUpdate(\n            req.params.id,\n            { name },\n            { new: true }\n        );\n        if (!tag) return res.status(404).json({ message: '标签未找到' });\n        res.json({ message: '标签更新成功', tag });\n    } catch (error) {\n        res.status(500).json({ message: '更新标签失败', error });\n    }\n});\n\n// 删除标签\nrouter.delete('/:id', auth, async (req, res) => {\n    try {\n        const tag = await Tag.findByIdAndDelete(req.params.id);\n        if (!tag) return res.status(404).json({ message: '标签未找到' });\n        res.json({ message: '标签删除成功' });\n    } catch (error) {\n        res.status(500).json({ message: '删除标签失败', error });\n    }\n});\n\nmodule.exports = router;\n```\n\n---\n\n## 4. 在 `app.js` 中挂载分类和标签路由\n\n在主文件 `app.js` 中导入分类和标签的路由文件，并挂载到指定路径，以便管理系统可以调用这些接口。\n\n```javascript\nconst categoryRoutes = require('./src/routes/category');\nconst tagRoutes = require('./src/routes/tag');\n\napp.use('/api/categories', categoryRoutes);\napp.use('/api/tags', tagRoutes);\n```\n\n---\n\n## 总结\n\n通过实现分类和标签的增删改查接口，个人博客管理系统的内容管理能力进一步增强。文章可以通过分类和标签进行组织和筛选，便于更细致的内容管理。分类和标签接口的实现过程包括：\n\n1. 定义分类和标签的 Mongoose 模型。\n2. 在分类和标签的路由文件中创建 CRUD 接口。\n3. 在主文件中挂载路由。\n\n---\n\n以上笔记详细记录了分类和标签管理功能的实现过程，为后续维护和扩展提供了清晰的参考。\n"},8069:function(n,e,t){"use strict";t.r(e),e["default"]="---\ntitle: \"博客管理系统后端-注册、登录、令牌\"\ndate: \"2024-11-08\"\n---\n\n## 前言\n\n在本篇博客中，我们将详细介绍如何从零开始搭建一个基于 Node.js、Express 和 MongoDB 的后台项目。\n本教程会以“xyblog-admin”项目为例，带领大家一步步完成基本的项目结构搭建、数据库连接、以及服务器启动。\n\n## 项目结构初始化\n\n1. 在项目目录（例如“xyblog-admin”）中，创建如下文件结构：\n\n   ```\n   xyblog-admin\n   ├── src\n   │   ├── config          # 配置文件（如数据库连接）\n   │   ├── controllers     # 控制器文件\n   │   ├── middlewares     # 中间件\n   │   ├── models          # 数据库模型\n   │   ├── routes          # 路由\n   │   └── utils           # 工具函数\n   ├── .env                # 环境变量文件\n   ├── app.js              # 项目主入口文件\n   └── package.json        # Node.js 项目配置文件\n   ```\n\n   这将帮助我们保持清晰的项目结构，便于后续扩展和维护。\n\n## 初始化 Node.js 项目\n\n1. 在项目根目录下，运行以下命令初始化 `package.json` 文件：\n\n   ```bash\n   npm init -y\n   ```\n\n2. 安装项目的主要依赖库：\n\n   ```bash\n   npm install express mongoose dotenv jsonwebtoken bcryptjs cors\n   ```\n\n3. 安装开发依赖（如 `nodemon` 用于开发环境的自动重启）：\n\n   ```bash\n   npm install nodemon --save-dev\n   ```\n\n4. 修改 `package.json` 文件，添加启动脚本：\n\n   ```json\n   \"scripts\": {\n       \"start\": \"node app.js\",\n       \"dev\": \"nodemon app.js\"\n   }\n   ```\n\n## 配置主入口文件 app.js\n\n在根目录下创建 `app.js` 文件，配置 Express 服务器和 MongoDB 数据库连接。以下是 `app.js` 的基本配置：\n\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\napp.use(cors());\napp.use(express.json());\n\n// 数据库连接\nmongoose.connect(process.env.MONGODB_URI, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n})\n.then(() => console.log('MongoDB Connected'))\n.catch((err) => console.log(err));\n\n// 基础路由测试\napp.get('/', (req, res) => {\n    res.send('xyblog Admin API Running');\n});\n\napp.listen(PORT, () => {\n    console.log(`Server running on port ${PORT}`);\n});\n```\n\n确保 `.env` 文件中定义了 `PORT` 和 `MONGODB_URI` 环境变量。\n\n## 创建 .env 文件\n\n在项目根目录下手动创建 `.env` 文件，配置以下内容：\n\n```plaintext\nPORT=3000\nMONGODB_URI=mongodb://localhost:27017/xyblog\nJWT_SECRET=your_jwt_secret\n```\n\n然后，在 `app.js` 文件的顶部确保加载 `dotenv`：\n\n```javascript\nrequire('dotenv').config();\n```\n\n## 启动服务器\n\n完成所有配置后，在终端中运行以下命令启动开发服务器：\n\n```bash\nnpm run dev\n```\n\n如果一切正常，你会在终端看到 `Server running on port 3000` 的输出，表示服务器已成功启动。现在，你可以在浏览器中访问 `http://localhost:3000` 并看到“xyblog Admin API Running”的消息，这表示你的服务器已启动并可以正常响应请求。\n\n## 总结\n\n到此为止，我们已经搭建了一个基于 Node.js、Express 和 MongoDB 的后台项目，并且成功启动了服务器。这是一个基本的项目结构，为后续的功能扩展提供了良好的基础。接下来可以继续完善 API 接口，实现更多功能。\n"},5947:function(n,e,t){"use strict";t.r(e),e["default"]="---\ntitle: \"博客管理系统后端-项目搭建\"\ndate: \"2024-11-08\"\n---\n\n在本篇博客中，我们将详细介绍如何从零开始搭建一个基于 Node.js、Express 和 MongoDB 的后台项目。\n本教程会以“xyblog-admin”项目为例，带领大家一步步完成基本的项目结构搭建、数据库连接、以及服务器启动。\n\n## 项目结构初始化\n\n1. 在项目目录（例如“xyblog-admin”）中，创建如下文件结构：\n\n   ```\n   xyblog-admin\n   ├── src\n   │   ├── config          # 配置文件（如数据库连接）\n   │   ├── controllers     # 控制器文件\n   │   ├── middlewares     # 中间件\n   │   ├── models          # 数据库模型\n   │   ├── routes          # 路由\n   │   └── utils           # 工具函数\n   ├── .env                # 环境变量文件\n   ├── app.js              # 项目主入口文件\n   └── package.json        # Node.js 项目配置文件\n   ```\n\n   这将帮助我们保持清晰的项目结构，便于后续扩展和维护。\n\n## 初始化 Node.js 项目\n\n1. 在项目根目录下，运行以下命令初始化 `package.json` 文件：\n\n   ```bash\n   npm init -y\n   ```\n\n2. 安装项目的主要依赖库：\n\n   ```bash\n   npm install express mongoose dotenv jsonwebtoken bcryptjs cors\n   ```\n\n3. 安装开发依赖（如 `nodemon` 用于开发环境的自动重启）：\n\n   ```bash\n   npm install nodemon --save-dev\n   ```\n\n4. 修改 `package.json` 文件，添加启动脚本：\n\n   ```json\n   \"scripts\": {\n       \"start\": \"node app.js\",\n       \"dev\": \"nodemon app.js\"\n   }\n   ```\n\n## 配置主入口文件 app.js\n\n在根目录下创建 `app.js` 文件，配置 Express 服务器和 MongoDB 数据库连接。以下是 `app.js` 的基本配置：\n\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\napp.use(cors());\napp.use(express.json());\n\n// 数据库连接\nmongoose.connect(process.env.MONGODB_URI, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n})\n.then(() => console.log('MongoDB Connected'))\n.catch((err) => console.log(err));\n\n// 基础路由测试\napp.get('/', (req, res) => {\n    res.send('xyblog Admin API Running');\n});\n\napp.listen(PORT, () => {\n    console.log(`Server running on port ${PORT}`);\n});\n```\n\n确保 `.env` 文件中定义了 `PORT` 和 `MONGODB_URI` 环境变量。\n\n## 创建 .env 文件\n\n在项目根目录下手动创建 `.env` 文件，配置以下内容：\n\n```plaintext\nPORT=3000\nMONGODB_URI=mongodb://localhost:27017/xyblog\nJWT_SECRET=your_jwt_secret\n```\n\n然后，在 `app.js` 文件的顶部确保加载 `dotenv`：\n\n```javascript\nrequire('dotenv').config();\n```\n\n## 启动服务器\n\n完成所有配置后，在终端中运行以下命令启动开发服务器：\n\n```bash\nnpm run dev\n```\n\n如果一切正常，你会在终端看到 `Server running on port 3000` 的输出，表示服务器已成功启动。现在，你可以在浏览器中访问 `http://localhost:3000` 并看到“xyblog Admin API Running”的消息，这表示你的服务器已启动并可以正常响应请求。\n\n## 总结\n\n到此为止，我们已经搭建了一个基于 Node.js、Express 和 MongoDB 的后台项目，并且成功启动了服务器。这是一个基本的项目结构，为后续的功能扩展提供了良好的基础。接下来可以继续完善 API 接口，实现更多功能。\n"},9530:function(n,e,t){"use strict";t.r(e),e["default"]="---\ntitle: \"博文章管理 CRUD 实现\"\ndate: \"2024-11-08\"\n---\n\n本文档将详细总结个人博客管理系统后端中**文章管理的增删改查（CRUD）**功能。该功能使用户能够通过接口实现文章的创建、查询、更新和删除操作，并对用户身份进行验证。这是博客管理后台的核心功能之一。\n\n## 项目结构\n\n本节涉及的项目结构如下：\n\n```\nproject-root\n├── src\n│   ├── models\n│   │   └── Post.js          # 文章模型\n│   ├── routes\n│   │   └── post.js          # 文章管理路由\n├── app.js                   # 主文件\n```\n\n## 1. 文章模型定义\n\n首先在 `src/models/Post.js` 中定义文章模型。每篇文章包括标题、内容、作者和创建时间等字段。\n\n### Post.js 模型代码：\n\n```javascript\n// src/models/Post.js\nconst mongoose = require('mongoose');\n\nconst postSchema = new mongoose.Schema({\n    title: { type: String, required: true },       // 文章标题\n    content: { type: String, required: true },     // 文章内容\n    author: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true }, // 作者引用\n    createdAt: { type: Date, default: Date.now }   // 创建时间\n});\n\nmodule.exports = mongoose.model('Post', postSchema);\n```\n\n### 字段解释\n\n- **title**：文章的标题，必填字段。\n- **content**：文章的内容，必填字段。\n- **author**：引用用户模型 `User`，确保文章有明确的创建者。\n- **createdAt**：文章的创建时间，默认为当前时间。\n\n## 2. 文章管理路由定义\n\n在 `src/routes/post.js` 中实现文章的增删改查接口，每个接口均为具体功能服务。\n\n### 路由文件 `post.js` 代码：\n\n```javascript\nconst express = require('express');\nconst auth = require('../middlewares/auth'); // 身份验证中间件\nconst Post = require('../models/Post'); // 文章模型\n\nconst router = express.Router();\n```\n\n### 2.1 创建文章接口\n\n通过此接口，经过身份验证的用户可以创建新文章。\n\n```javascript\n// 创建文章接口\nrouter.post('/create', auth, async (req, res) => {\n    const { title, content } = req.body;\n    const author = req.user.userId; // 从身份验证中间件获取用户ID\n\n    try {\n        const post = new Post({ title, content, author });\n        await post.save();\n        res.status(201).json({ message: '文章创建成功', post });\n    } catch (error) {\n        res.status(500).json({ message: '文章创建失败', error });\n    }\n});\n```\n\n#### 注意点\n\n- `auth` 中间件确保只有登录用户才能创建文章。\n- `post.save()` 将新文章保存到数据库，成功后返回创建的文章信息。\n\n### 2.2 获取所有文章接口\n\n此接口用于获取数据库中的所有文章，主要用于展示文章列表。\n\n```javascript\n// 获取所有文章\nrouter.get('/', async (req, res) => {\n    try {\n        const posts = await Post.find().populate('author', 'username');\n        res.json(posts);\n    } catch (error) {\n        res.status(500).json({ message: '获取文章失败', error });\n    }\n});\n```\n\n#### 注意点\n\n- `Post.find()` 获取所有文章。\n- `populate('author', 'username')` 用于展示文章作者的用户名，而不是作者 ID。\n\n### 2.3 获取单篇文章接口\n\n此接口根据文章 ID 返回具体文章内容，适用于文章详情页。\n\n```javascript\n// 获取单篇文章\nrouter.get('/:id', async (req, res) => {\n    try {\n        const post = await Post.findById(req.params.id).populate('author', 'username');\n        if (!post) return res.status(404).json({ message: '文章未找到' });\n        res.json(post);\n    } catch (error) {\n        res.status(500).json({ message: '获取文章失败', error });\n    }\n});\n```\n\n#### 注意点\n\n- `Post.findById(req.params.id)` 通过文章 ID 获取特定文章。\n- 如果文章不存在，返回 `404 Not Found` 错误。\n\n### 2.4 更新文章接口\n\n此接口允许文章作者更新自己的文章，非作者无权限更新。\n\n```javascript\n// 更新文章\nrouter.put('/:id', auth, async (req, res) => {\n    const { title, content } = req.body;\n\n    try {\n        const post = await Post.findOneAndUpdate(\n            { _id: req.params.id, author: req.user.userId },\n            { title, content },\n            { new: true }\n        );\n        if (!post) return res.status(404).json({ message: '文章未找到或无权限更新' });\n        res.json({ message: '文章更新成功', post });\n    } catch (error) {\n        res.status(500).json({ message: '更新文章失败', error });\n    }\n});\n```\n\n#### 注意点\n\n- 使用 `auth` 中间件确保用户已登录。\n- `findOneAndUpdate` 方法根据文章 ID 和作者 ID 更新文章，以确保只有作者可以更新。\n\n### 2.5 删除文章接口\n\n此接口允许文章作者删除自己的文章，非作者无权限删除。\n\n```javascript\n// 删除文章\nrouter.delete('/:id', auth, async (req, res) => {\n    try {\n        const post = await Post.findOneAndDelete({ _id: req.params.id, author: req.user.userId });\n        if (!post) return res.status(404).json({ message: '文章未找到或无权限删除' });\n        res.json({ message: '文章删除成功' });\n    } catch (error) {\n        res.status(500).json({ message: '删除文章失败', error });\n    }\n});\n```\n\n#### 注意点\n\n- 使用 `auth` 中间件确保用户已登录。\n- `findOneAndDelete` 方法根据文章 ID 和作者 ID 删除文章，确保只有作者可以删除。\n\n## 3. 总结\n\n通过以上增删改查（CRUD）接口的实现，个人博客管理系统的文章管理功能已基本完备，支持创建、查看、更新和删除文章。实现这些接口后，可以进一步扩展其他功能，例如分类管理、标签管理等，以完善博客管理后台。\n\n---\n\n本笔记涵盖了文章管理功能的实现细节，并通过具体代码提供了解决方案，便于后续复习和参考。\n"},9229:function(n,e,t){"use strict";var o=t(5130),s=t(6768);const r={id:"app"};function a(n,e,t,o,a,i){const c=(0,s.g2)("router-view");return(0,s.uX)(),(0,s.CE)("div",r,[(0,s.bF)(c)])}var i={name:"App"},c=t(1241);const g=(0,c.A)(i,[["render",a]]);var A=g,u=t(973),l=t(4232),p="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAAEL5JREFUeF7tnU12FLkSRlWwMMwCgHFN4bAO43X04U09bnoBuBeG6x05O6EwdmXGJyn1yXmZcaxQSjdCt5RV+XNI/IMABHZL4LDbmTNxCEAgIQCKAAI7JoAAdpx8pg4BBEANQGDHBBDAjpPP1CGAAKgBCOyYAALYcfKZOgQQADUAgR0TQAA7Tj5ThwACoAYgsGMCCGDHyWfqEEAA1AAEdkwAAew4+UwdAgiAGoDAjgkggB0nn6lDAAFQAxDYMQEEsOPkM3UIIABqAAI7JoAAdpx8pg4BBEANQGDHBBDAjpPP1CGAAKgBCOyYAALYcfKZOgQQADUAgR0TQACVkv/X7T9Xr9L91X16dff5+O6uUrd0c0YgM57/C+M6pYEACjjmgnydTtenlH4W5q/uTjefjh++FHRP6H8EJrmevv8JBMalRYIARIJfb//+ktLh+nI4BSri/Rm2hvN9OrxlR6CRRgAat/T19ttpXSgSWMfpz1ZrFv8c9en4nloWQANNgBYpzNw9n1AC5JQCkk35HXd3H4/v32pH2m8UAhByv/7Tf+ocAcQhRyWbj8AuIM4ZAcSZhT6Zpu45DYhiVgSAaKOUH3ZO/IsQeP4b6Uu9IIAI49wWAUSJae0RQJAbAggCE5sjABFcMAwBBIEhgCAwsTkCEMEFwxBAEBgCCAITmyMAEVwwDAEEgSGAIDCxOQIQwQXDEEAQGAIIAhObIwARXDAMAQSBIYAgMLE5AhDBBcMQQBAYAggCE5sjABFcMAwBBIEhgCAwsTkCEMEFwxBAEBgCCAITmyMAEVwwDAEEgSGAIDCxOQIQwQXDEEAQGAIIAhObIwARXDDsxQjg/HFREQbRB0lsJQB1PpG5b9U2yjiPaysBKJyV+WzFOnqcIQUwP4orT/bpx3GtxxC9hXQrASgLYP2st24ZvxlKmb9yN2D01u7H5PJzCE7p9O+oz4IcSgBKUSyVOgJYIlTj7y9XAH/Sic+1BmG1jyEE0GLhz8AQgFo6kbj4olBy3mMH8DyF+JwjRGu1tRbA5afu1kGAAOpwvNxLfDGML4DpMWU/0uHG+TsDWwFo59rxYkYAcWbxiH0K4Ben+PzjjLUISwEo9temH3+OnCameAFsyUBltz5um/l7nQI8phNnsJ6v3tJOAFsXPjsAvXjWR8aLX6kDbwF4PhzWUABrn7e/vvwutUQAdTjyHcA6joqk1vWstbISwP9uv30v/V0/igEBRIkp7dkBzNTc3l9gIwBly6eU4uMYBFCD4lIfCOCckNMuwEgA227954QggKXFW+PvCOCcotMuwEIAvT79c1IQQI0FvtQHAnhMyGUXYCGAGuf+8zXZS6X45ylA7BXeW/0MOB3n/onXjkdn2L+9cp288qGgLKrpOLF/h3R4U/pdlcsuwEIA6g0ZPa602koAsZJ8ea23EkAJOWWMbt8FdBeADjG+rSxJ9hyLAGpQXO5DqQtlB7A8kuUW6g6213gffR+xPMGWLZREK+futeaAAGqRvNyPUhc9F5Syi3U4Dei+A9Ds2efTP5csAkAATxFQ6gIBpJQUAUS/ua9ZskqieT14PAOj7QDyDKO7AAQgQOu5/WcHEF/IasSIAhjtwyznpvspwGjWZAegLulYHAKI8VJbI4AgOQQQBCY2RwAiuGAYAggCQwBBYGJzBCCCC4YhgCAwBBAEJjZHACK4YBgCCAJDAEFgYnMEIIILhiGAIDAEEAQmNkcAIrhgGAIIAkMAQWBicwQggguGIYAgsNw8+tMlFwLFISui7XmBWJ4h1wHE8xxeTA5XT0UT3fMadSElFiFRAYxYFxl0b2mxAxDKPVac/e5bEKZmFRITbX/OsfFOqBHAbexRYA6mn04D8oMkDtdLK6Z3gpfG5/73dadb/Rc/pwBiJa1L8K/OXQSwJIEeDysRU2Afdlm2HosfAYhlNLIA5inPj5WaHhU17quixRRuEnbOOB/QkTOnAEIpvAQBCNMm5AUSQABCUhGAAI0QSwIIQEgLAhCgEWJJAAEIaUEAAjRCLAkgACEtCECARoglAQQgpAUBCNAIsSSAAIS0IAABGiGWBBCAkBYEIEAjxJIAAhDSggAEaIRYEkAAQloQgACNEEsCCEBICwIQoBFiSQABCGlBAAI0QiwJIAAhLYoA8o0gwqEIgUBjAsu3hz8eQO/bxYd7IEjjDNI9BDYlgACCDwTZNDscDAKNCSAABNC4xOjemQACQADO9cnYGhNAAAigcYnRvTMBBIAAnOuTsTUmgAAQQOMSo3tnAggAATjXJ2NrTAABIIDGJUb3zgQQAAJwrk/G1pgAAkAAjUuM7p0JIAAE4FyfjK0xAQQgCeB00zgvdA+BMIHpzVDpKhKIAIICcHo3YCTRtH35BLgdWMixcjvwx+P7t8KhCIFAUwIIQMCLAARohFgSQABCWhCAAI0QSwIIQEgLAhCgEWJJAAEIaUEAAjRCLAkgACEtCECARoglAQQgpAUBCNAIsSSAAIS0IAABGiGWBBCAkBYEIEAjxJIAAhDSggAEaIRYEkAAQloQgACNEEsCCEBICwIQoBFiSQABCGlBAAI0QiwJIAAhLQhAgEaIJQEEIKQFAQjQCLEkgACEtCAAARohlgQQgJAWBCBAI8SSAAIQ0oIABGiEWBJAAEJaEIAAjRBLAghASAsCEKARYkkAAQhpQQACNEIsCSAAIS0IQIBGiCUBBCCkBQEI0AixJIAAhLQgAAEaIZYEEICQlji0082n44cvwqGahPx1+8/V63S6zp1H3wozDyi/7OSUTv/WnJfruPKc57GpvCZu09uhajIrLZB4Lefxvz+UHrckvuvB88Dj0HwEEB/75VRlEfxIh5vPx3d3JUn9evv3l5QOD1Kq96+ce52F/3hG5eOqxUiph90LIBfFq3T6vjYJvYHN42yzyFIqffVZq3Hled+nw9sSOUVP99bWRCmztcdZaocAlgg98/f1Reth+/XjFYEkfZ6tFtk8E1XAzszULD2OQwAFJJcLRF8UBcN6MlRJdHQMykJbZhgdxZ/t1V1AazE57AKUulDyXJ7FXz10/w7gfDLT6cD91fya5ZzU/Pca58U1obUuZnW7vYUAlIUWPc1Tc9V7MSEANXMDxW1VzMonrVKAUfTOAlCYRed/qb3Cv7e0rHYANZPRsi/XHYBSgHFO8VOxraTZezEp/HuPGQHEV4Dw02X8IEphbLPQ4gLIs28tTWVnEs/K5QgEUJuoaX/tF5q2yDIupQjXYi5ZZO2/n9CZrZ3/UjuFvSL6pXFE/s4OIELrrG2rgi5ZZHl4LeVUeo6tLJB16em/+FX5IoB1GbZsVV8CdQq59hV3ta5QnE4Fal+lWIdZjQJTBIcAapDv3MdU1PkqvsMbZSj5PoD79Oqu5Cq7p45bOq7cZ4ufYGuMqxUzJX9zDAIooUcsBAYngAAGTyDDh0AJAQRQQo9YCAxOAAEMnkCGD4ESAgighB6xEBicAAIYPIEMHwIlBBBACT1iITA4AQQweAIZPgRKCCCAEnrEQmBwAghg8AQyfAiUEEAAJfSIhcDgBBDA4Alk+BAoIYAASuidvTAid5NfGtHihRmFQyQcAs8SQAAFxbF8m6jPbZ8F0yT0BRNAAGJylxf/1HHpAynE4REGgVUEEMAqTL83ij7BpvcDFIQpErITAghASPTaT/+5a3YBAmRCNiGAAATMUWilz8wThkgIBFYRiNZy7rT3jrb7Q0Gjj4tGAKtqkUYdCCAAAToCEKARYkkAAQhpQQACNEIsCSAAIS0IQIBGiCUBBCCkBQEI0AixJIAAhLQgAAEaIZYEEICQFgQgQCPEkgACENLyEgQwXc14fyVM/2fIp+OHh7cL1fyXx5X7KxlbizcWuY6rlD0CEAiOLIDa7+BLqd4NT0oxPp++euOKXvm5XFL1xrZ8rMstFOZcCHT77RQB73IhUP1CnimUF3RUqmv5l16G7cxsLYNL7RCAQDFarA4CiN7AFMVSstDaLbL88tN09/H4/m10Prl9y3Hl/kuYKfN5KgYBCCRHFEDrYs4Yla3hFuNSF1o0z9FSKpFT9FjPtUcAAsloYTgkOjpmAYv0ibaFAJTvKVrvmGa+ijSV3CCAitSiiwkBPA9f+QSKplLhv42Y+p8GKPx7S4u7AaMr4OF8NvbFpXAIaQegFGB8bPEvKdkBPE8ZAQQXk/IJFC/y+j/3RMegFMY2n7RxAUxfAraXpsIsmhd+BahJTCgMBwG0X2jaItvik1ZdZO13JxqzmuWszFHlWWvcnAKIJJVkrz1USVG0lZO+yFrKyeFDIedWqYmSXK+tp0vtEIBIsf5VgNNA1J/ZzqfRRgL64p/H1mJcefH/SIebz8d3d2Iqq4UhAAFl9NzQxfa1i7r2vPJiO6TDm/yCFSEtP0NaLLAaInB8aQwCECptdAGcT3m+ySWKofWnl+u4MidlbK15RfM3t0cAArmXJABh+oS8IAIIQEgmAhCgEWJJAAEIaUEAAjRCLAkgACEtCECARoglAQQgpAUBCNAIsSSAAIS0IAABGiGWBBCAkBYEIEAjxJIAAhDSggAEaIRYEkAAQloQgACNEEsCCEBICwIQoBFiSQABCGlBAAI0QiwJIAAhLQhAgEaIJQEEIKQFAQjQCLEkgACEtCAAARohlgQQgJAWBCBAI8SSAAIQ0oIABGiEWBJAAEJaEIAAjRBLAghASAsCEKARYkkAAQhpQQACNEIsCSAAIS0IQIBGiCUBBCCkBQEI0AixJIAAhLQgAAEaIZYEEICQFgQgQCPEkgACENKCAARohFgSQABCWhCAAI0QSwIIQEhLVAD5EL1fqChMk5AdEBixlru/HFSxZo0XaO6gHpnixgSiAqj9PkhlukMKIKXyN9UqsIiBwHMElBeeIgDxneo5CewCWIwuBPILTl+l0/f4ePp/kHXfAajwWry2Op5AIvZOINfv63S61l7DjgAe6id67vR70fWHuPdFsMf5Tx9c91cpHa7V+Tt8md19B5DhKV8EPgU97wrUZBAHgbUEtE/733t3OP/PI7IQgHoasDZhtIOAHwGPnauFAGruAvwSzYgg8JiAx+K32QHkgbALYJnshwACeDLXtb4L2E8hMdPxCPgsfqsdwJxIJDBeSTPidQRcvvg7H63NdwDzoDgVWFdMtBqPgOPFa3YC4PuA8QqbES8TcFz8lqcA5zsB/Qqr5YTQAgJbEHC/YtVyB3CeGOUmiy0SyzEgsETA8Zz/8ZjtBZAHPEngYcMiX3a5lCz+DoFaBNw/9a2/BLyUhCyCQzq8qXEpZq1k0w8EZgIjLfyzMY+ZwHlXkIWQZ4AUxszjqKM+v+/kRzrcfD6+G/I+lCFOAUYtEsYNAXcCCMA9Q4wPAg0JIICGcOkaAu4EEIB7hhgfBBoSQAAN4dI1BNwJIAD3DDE+CDQkgAAawqVrCLgTQADuGWJ8EGhIAAE0hEvXEHAngADcM8T4INCQAAJoCJeuIeBOAAG4Z4jxQaAhAQTQEC5dQ8CdAAJwzxDjg0BDAgigIVy6hoA7AQTgniHGB4GGBBBAQ7h0DQF3AgjAPUOMDwINCSCAhnDpGgLuBBCAe4YYHwQaEkAADeHSNQTcCSAA9wwxPgg0JIAAGsKlawi4E0AA7hlifBBoSAABNIRL1xBwJ4AA3DPE+CDQkAACaAiXriHgTgABuGeI8UGgIQEE0BAuXUPAnQACcM8Q44NAQwIIoCFcuoaAOwEE4J4hxgeBhgT+D5FyTaatFmqGAAAAAElFTkSuQmCC";const d={class:"bottom-rounded-bg"},m={class:"blog-list"},h=["onClick"],I=["innerHTML"],j={class:"blog-title-container"},B={class:"blog-title-content"},C={class:"pagination"},v=["disabled"],y=["disabled"];function E(n,e,t,o,r,a){return(0,s.uX)(),(0,s.CE)(s.FK,null,[e[4]||(e[4]=(0,s.Lk)("div",{class:"rounded-bg"},[(0,s.Lk)("h1",{class:"title"},"强风吹拂，聚散流云")],-1)),(0,s.Lk)("div",d,[e[3]||(e[3]=(0,s.Lk)("h2",{class:"blog-title"},"sunduskxy",-1)),(0,s.Lk)("ul",m,[((0,s.uX)(!0),(0,s.CE)(s.FK,null,(0,s.pI)(a.paginatedBlogs,((n,t)=>((0,s.uX)(),(0,s.CE)("li",{class:"blog-item",key:t,onClick:e=>a.goToBlog(n.id)},[(0,s.Lk)("h3",null,(0,l.v_)(n.title),1),(0,s.Lk)("div",{innerHTML:a.getTruncatedContent(n.content),class:"blog-content"},null,8,I),(0,s.Lk)("div",j,[e[2]||(e[2]=(0,s.Lk)("img",{src:p,alt:"日期图标",class:"date-icon"},null,-1)),(0,s.Lk)("p",B,(0,l.v_)(n.date),1)])],8,h)))),128))]),(0,s.Lk)("div",C,[(0,s.Lk)("button",{onClick:e[0]||(e[0]=n=>a.changePage(r.currentPage-1)),disabled:1===r.currentPage},"上一页",8,v),(0,s.Lk)("span",null,"第 "+(0,l.v_)(r.currentPage)+" 页，共 "+(0,l.v_)(a.totalPages)+" 页",1),(0,s.Lk)("button",{onClick:e[1]||(e[1]=n=>a.changePage(r.currentPage+1)),disabled:r.currentPage===a.totalPages},"下一页",8,y)])])],64)}t(4114);var b=t(357),f=t(7221),Q={name:"XYHome",data(){return{blogs:[],currentPage:1,pageSize:10,contentLimit:150}},computed:{totalPages(){return Math.ceil(this.blogs.length/this.pageSize)},paginatedBlogs(){const n=(this.currentPage-1)*this.pageSize;return this.blogs.slice(n,n+this.pageSize)}},methods:{loadBlogs(){try{const n=t(653),e=n.keys().map((e=>{const t=n(e).default,o=t.match(/---\s*([\s\S]*?)\s*---/);let s={date:"未知日期",title:"未知标题"};if(o){const n=o[1];s=f.Ay.load(n)}const r=(0,b.xI)(t.replace(/---\s*([\s\S]*?)\s*---/,""));return{id:e.slice(2,-3),title:s.title||"未知标题",content:r,date:s.date||"未知日期"}}));this.blogs=e.sort(((n,e)=>new Date(e.date)-new Date(n.date)))}catch(n){console.error("加载博客文章时出错:",n)}},goToBlog(n){this.$router.push({name:"XYBlogDetail",params:{id:n}})},changePage(n){n>=1&&n<=this.totalPages&&(this.currentPage=n,window.scrollTo({top:0,behavior:"smooth"}))},getTruncatedContent(n){const e=n.replace(/(<([^>]+)>)/gi,"");return e.length>this.contentLimit?(0,b.xI)(e.slice(0,this.contentLimit)+"..."):n}},mounted(){this.loadBlogs()}};const w=(0,c.A)(Q,[["render",E]]);var x=w;const D={class:"blog-detail"},S={class:"header-image"},k={class:"blog-date"},P=["innerHTML"];function T(n,e,t,o,r,a){return(0,s.uX)(),(0,s.CE)("div",D,[(0,s.Lk)("div",S,[(0,s.Lk)("h1",null,(0,l.v_)(r.blogTitle),1),(0,s.Lk)("p",k,(0,l.v_)(r.blogDate),1)]),(0,s.Lk)("div",{class:"content-card",innerHTML:r.blogContent},null,8,P)])}var O={name:"XYBlogDetail",data(){return{blogTitle:"",blogContent:"",blogDate:""}},created(){const n=this.$route.params.id;this.fetchBlogContent(n)},methods:{fetchBlogContent(n){const e=t(653),o=`./${n}.md`;if(e.keys().includes(o)){const n=e(o).default,t=n.match(/---\s*([\s\S]*?)\s*---/);let s={date:"未知日期",title:"未知标题"};if(t){const n=t[1];s=f.Ay.load(n)}this.blogTitle=s.title||"未知标题",this.blogContent=(0,b.xI)(n.replace(/---\s*([\s\S]*?)\s*---/,"")),this.blogDate=s.date||"未知日期"}else this.blogTitle="博客未找到",this.blogContent="抱歉，没有找到您请求的博客内容。",this.blogDate=""}}};const R=(0,c.A)(O,[["render",T]]);var q=R;const M=[{path:"/",name:"XYHome",component:x},{path:"/blog/:id",name:"XYBlogDetail",component:q}],U=(0,u.aE)({history:(0,u.Bt)(),routes:M});var L=U;const N=(0,o.Ef)(A);N.use(L),N.mount("#app")},653:function(n,e,t){var o={"./JavaScript后端使用-创建API.md":4729,"./Python简单的开发流程.md":1142,"./Vue 组件全局样式和作用域问题：避免页面上下出现白色间隔.md":2072,"./Vue笔记-注册路由跳转.md":1940,"./Vue笔记-项目创建.md":7041,"./macOS下本地 MongoDB 安装、启动及项目集成指南.md":1013,"./分类和标签管理实现总结.md":1517,"./博客管理系统后端-注册、登录、令牌.md":8069,"./博客管理系统后端-项目搭建.md":5947,"./博文章管理 CRUD 实现.md":9530};function s(n){var e=r(n);return t(e)}function r(n){if(!t.o(o,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return o[n]}s.keys=function(){return Object.keys(o)},s.resolve=r,n.exports=s,s.id=653}},e={};function t(o){var s=e[o];if(void 0!==s)return s.exports;var r=e[o]={exports:{}};return n[o].call(r.exports,r,r.exports,t),r.exports}t.m=n,function(){var n=[];t.O=function(e,o,s,r){if(!o){var a=1/0;for(A=0;A<n.length;A++){o=n[A][0],s=n[A][1],r=n[A][2];for(var i=!0,c=0;c<o.length;c++)(!1&r||a>=r)&&Object.keys(t.O).every((function(n){return t.O[n](o[c])}))?o.splice(c--,1):(i=!1,r<a&&(a=r));if(i){n.splice(A--,1);var g=s();void 0!==g&&(e=g)}}return e}r=r||0;for(var A=n.length;A>0&&n[A-1][2]>r;A--)n[A]=n[A-1];n[A]=[o,s,r]}}(),function(){t.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return t.d(e,{a:e}),e}}(),function(){t.d=function(n,e){for(var o in e)t.o(e,o)&&!t.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:e[o]})}}(),function(){t.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"===typeof window)return window}}()}(),function(){t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)}}(),function(){t.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})}}(),function(){var n={524:0};t.O.j=function(e){return 0===n[e]};var e=function(e,o){var s,r,a=o[0],i=o[1],c=o[2],g=0;if(a.some((function(e){return 0!==n[e]}))){for(s in i)t.o(i,s)&&(t.m[s]=i[s]);if(c)var A=c(t)}for(e&&e(o);g<a.length;g++)r=a[g],t.o(n,r)&&n[r]&&n[r][0](),n[r]=0;return t.O(A)},o=self["webpackChunkmy_blog"]=self["webpackChunkmy_blog"]||[];o.forEach(e.bind(null,0)),o.push=e.bind(null,o.push.bind(o))}();var o=t.O(void 0,[504],(function(){return t(9229)}));o=t.O(o)})();
//# sourceMappingURL=app.a20690b0.js.map